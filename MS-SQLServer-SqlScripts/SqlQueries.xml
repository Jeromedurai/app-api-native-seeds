<?xml version="1.0" encoding="utf-8"?>
<queries>
	<!-- ====================================== -->
	<!-- DATABASE SCHEMA CREATION AND OPTIMIZATION -->
	<!-- ====================================== -->
	
	<query Id="CREATE_DATABASE_SCHEMA">
		<![CDATA[
			-- ====================================== 
			-- COMPREHENSIVE E-COMMERCE DATABASE SCHEMA
			-- Optimized for Performance and Scalability
			-- ====================================== 
			
			-- Drop existing tables in correct order (foreign key dependencies)
			IF OBJECT_ID('UserCustomPermissions', 'U') IS NOT NULL DROP TABLE UserCustomPermissions;
			IF OBJECT_ID('RolePermissions', 'U') IS NOT NULL DROP TABLE RolePermissions;
			IF OBJECT_ID('UserRoles', 'U') IS NOT NULL DROP TABLE UserRoles;
			IF OBJECT_ID('UserTokens', 'U') IS NOT NULL DROP TABLE UserTokens;
			IF OBJECT_ID('UserSessions', 'U') IS NOT NULL DROP TABLE UserSessions;
			IF OBJECT_ID('UserNotifications', 'U') IS NOT NULL DROP TABLE UserNotifications;
			IF OBJECT_ID('UserActivityLog', 'U') IS NOT NULL DROP TABLE UserActivityLog;
			IF OBJECT_ID('UserAddresses', 'U') IS NOT NULL DROP TABLE UserAddresses;
			IF OBJECT_ID('UserPreferences', 'U') IS NOT NULL DROP TABLE UserPreferences;
			IF OBJECT_ID('UserBehaviorAnalytics', 'U') IS NOT NULL DROP TABLE UserBehaviorAnalytics;
			IF OBJECT_ID('PasswordResetTokens', 'U') IS NOT NULL DROP TABLE PasswordResetTokens;
			IF OBJECT_ID('OrderTracking', 'U') IS NOT NULL DROP TABLE OrderTracking;
			IF OBJECT_ID('OrderStatusHistory', 'U') IS NOT NULL DROP TABLE OrderStatusHistory;
			IF OBJECT_ID('OrderRefunds', 'U') IS NOT NULL DROP TABLE OrderRefunds;
			IF OBJECT_ID('OrderItems', 'U') IS NOT NULL DROP TABLE OrderItems;
			IF OBJECT_ID('OrderAnalytics', 'U') IS NOT NULL DROP TABLE OrderAnalytics;
			IF OBJECT_ID('Orders', 'U') IS NOT NULL DROP TABLE Orders;
			IF OBJECT_ID('NotificationQueue', 'U') IS NOT NULL DROP TABLE NotificationQueue;
			IF OBJECT_ID('CartItems', 'U') IS NOT NULL DROP TABLE CartItems;
			IF OBJECT_ID('ProductWishList', 'U') IS NOT NULL DROP TABLE ProductWishList;
			IF OBJECT_ID('ProductReviews', 'U') IS NOT NULL DROP TABLE ProductReviews;
			IF OBJECT_ID('ProductImages', 'U') IS NOT NULL DROP TABLE ProductImages;
			IF OBJECT_ID('Products', 'U') IS NOT NULL DROP TABLE Products;
			IF OBJECT_ID('Categories', 'U') IS NOT NULL DROP TABLE Categories;
			IF OBJECT_ID('ProductCategories', 'U') IS NOT NULL DROP TABLE ProductCategories;
			IF OBJECT_ID('MenuMaster', 'U') IS NOT NULL DROP TABLE MenuMaster;
			IF OBJECT_ID('Permissions', 'U') IS NOT NULL DROP TABLE Permissions;
			IF OBJECT_ID('Roles', 'U') IS NOT NULL DROP TABLE Roles;
			IF OBJECT_ID('Users', 'U') IS NOT NULL DROP TABLE Users;
			IF OBJECT_ID('XC_APPCONFIG', 'U') IS NOT NULL DROP TABLE XC_APPCONFIG;

			-- ====================================== 
			-- CORE SYSTEM TABLES
			-- ====================================== 

			-- Application Configuration Table
			CREATE TABLE XC_APPCONFIG (
				ConfigId BIGINT IDENTITY(1,1) NOT NULL,
				ConfigKey NVARCHAR(255) NOT NULL,
				ConfigValue NVARCHAR(MAX) NULL,
				Description NVARCHAR(500) NULL,
				DataType NVARCHAR(50) DEFAULT 'String' NOT NULL,
				IsEncrypted BIT DEFAULT 0 NOT NULL,
				Category NVARCHAR(100) DEFAULT 'General' NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				UpdatedBy BIGINT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CONSTRAINT PK_XC_APPCONFIG PRIMARY KEY CLUSTERED (ConfigId),
				CONSTRAINT UQ_XC_APPCONFIG_ConfigKey UNIQUE (ConfigKey)
			);

			-- Users Table - Core user information
			CREATE TABLE Users (
				UserId BIGINT IDENTITY(1,1) NOT NULL,
				FirstName NVARCHAR(100) NOT NULL,
				LastName NVARCHAR(100) NOT NULL,
				Email NVARCHAR(255) NOT NULL,
				Phone NVARCHAR(20) NULL,
				PasswordHash NVARCHAR(255) NOT NULL,
				Salt NVARCHAR(255) NOT NULL,
				TenantId BIGINT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				EmailVerified BIT DEFAULT 0 NOT NULL,
				PhoneVerified BIT DEFAULT 0 NOT NULL,
				LoginAttempts INT DEFAULT 0 NOT NULL,
				AccountLocked BIT DEFAULT 0 NOT NULL,
				LastLoginAttempt DATETIME2(7) NULL,
				LastLogin DATETIME2(7) NULL,
				LastLogout DATETIME2(7) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				-- Extended Profile Fields
				ProfilePicture NVARCHAR(500) NULL,
				DateOfBirth DATE NULL,
				Gender NVARCHAR(20) NULL,
				Timezone NVARCHAR(100) DEFAULT 'UTC' NULL,
				Language NVARCHAR(10) DEFAULT 'en' NULL,
				Country NVARCHAR(100) NULL,
				City NVARCHAR(100) NULL,
				State NVARCHAR(100) NULL,
				PostalCode NVARCHAR(20) NULL,
				Bio NVARCHAR(MAX) NULL,
				Website NVARCHAR(255) NULL,
				CompanyName NVARCHAR(255) NULL,
				JobTitle NVARCHAR(255) NULL,
				PreferredContactMethod NVARCHAR(50) DEFAULT 'Email' NULL,
				NotificationSettings NVARCHAR(MAX) NULL, -- JSON
				PrivacySettings NVARCHAR(MAX) NULL, -- JSON
				-- Security Fields
				PasswordChangedAt DATETIME2(7) NULL,
				LastPasswordReset DATETIME2(7) NULL,
				RememberMeToken NVARCHAR(255) NULL,
				RememberMeExpiry DATETIME2(7) NULL,
				AgreeToTerms BIT DEFAULT 0 NOT NULL,
				TermsAcceptedAt DATETIME2(7) NULL,
				CONSTRAINT PK_Users PRIMARY KEY CLUSTERED (UserId),
				CONSTRAINT UQ_Users_Email UNIQUE (Email),
				CONSTRAINT UQ_Users_Phone UNIQUE (Phone),
				CONSTRAINT CK_Users_LoginAttempts CHECK (LoginAttempts >= 0 AND LoginAttempts <= 10)
			);

			-- Roles Table - User roles and permissions
			CREATE TABLE Roles (
				RoleId BIGINT IDENTITY(1,1) NOT NULL,
				RoleName NVARCHAR(50) NOT NULL,
				RoleDescription NVARCHAR(255) NULL,
				RoleLevel INT DEFAULT 1 NOT NULL, -- Hierarchy level
				IsSystemRole BIT DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				UpdatedBy BIGINT NULL,
				CONSTRAINT PK_Roles PRIMARY KEY CLUSTERED (RoleId),
				CONSTRAINT UQ_Roles_RoleName UNIQUE (RoleName),
				CONSTRAINT CK_Roles_RoleLevel CHECK (RoleLevel >= 1 AND RoleLevel <= 10)
			);

			-- Permissions Table - System permissions
			CREATE TABLE Permissions (
				PermissionId BIGINT IDENTITY(1,1) NOT NULL,
				PermissionName NVARCHAR(100) NOT NULL,
				PermissionDescription NVARCHAR(255) NULL,
				PermissionCategory NVARCHAR(100) DEFAULT 'General' NULL,
				ResourceType NVARCHAR(50) NULL, -- Product, Order, User, etc.
				ActionType NVARCHAR(50) NULL, -- View, Create, Update, Delete
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_Permissions PRIMARY KEY CLUSTERED (PermissionId),
				CONSTRAINT UQ_Permissions_PermissionName UNIQUE (PermissionName)
			);

			-- User Roles Junction Table
			CREATE TABLE UserRoles (
				UserRoleId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				RoleId BIGINT NOT NULL,
				AssignedBy BIGINT NULL,
				AssignedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ExpiresAt DATETIME2(7) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserRoles PRIMARY KEY CLUSTERED (UserRoleId),
				CONSTRAINT FK_UserRoles_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_UserRoles_Roles FOREIGN KEY (RoleId) REFERENCES Roles(RoleId),
				CONSTRAINT FK_UserRoles_AssignedBy FOREIGN KEY (AssignedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_UserRoles_UserRole UNIQUE (UserId, RoleId, Active)
			);

			-- Role Permissions Junction Table
			CREATE TABLE RolePermissions (
				RolePermissionId BIGINT IDENTITY(1,1) NOT NULL,
				RoleId BIGINT NOT NULL,
				PermissionId BIGINT NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_RolePermissions PRIMARY KEY CLUSTERED (RolePermissionId),
				CONSTRAINT FK_RolePermissions_Roles FOREIGN KEY (RoleId) REFERENCES Roles(RoleId),
				CONSTRAINT FK_RolePermissions_Permissions FOREIGN KEY (PermissionId) REFERENCES Permissions(PermissionId),
				CONSTRAINT UQ_RolePermissions_RolePermission UNIQUE (RoleId, PermissionId)
			);

			-- User Custom Permissions Table
			CREATE TABLE UserCustomPermissions (
				UserCustomPermissionId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				PermissionId BIGINT NOT NULL,
				GrantedBy BIGINT NOT NULL,
				GrantedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ExpiresAt DATETIME2(7) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserCustomPermissions PRIMARY KEY CLUSTERED (UserCustomPermissionId),
				CONSTRAINT FK_UserCustomPermissions_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_UserCustomPermissions_Permissions FOREIGN KEY (PermissionId) REFERENCES Permissions(PermissionId),
				CONSTRAINT FK_UserCustomPermissions_GrantedBy FOREIGN KEY (GrantedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_UserCustomPermissions_UserPermission UNIQUE (UserId, PermissionId)
			);

			-- ====================================== 
			-- PRODUCT CATALOG TABLES
			-- ====================================== 

			-- Menu Master Table
			CREATE TABLE MenuMaster (
				MenuId BIGINT IDENTITY(1,1) NOT NULL,
				MenuName NVARCHAR(255) NOT NULL,
				OrderBy INT DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				Image NVARCHAR(500) NULL,
				SubMenu BIT DEFAULT 0 NOT NULL,
				TenantId BIGINT NULL,
				Created DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				Modified DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				ModifiedBy BIGINT NULL,
				CONSTRAINT PK_MenuMaster PRIMARY KEY CLUSTERED (MenuId),
				CONSTRAINT FK_MenuMaster_CreatedBy FOREIGN KEY (CreatedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_MenuMaster_ModifiedBy FOREIGN KEY (ModifiedBy) REFERENCES Users(UserId)
			);

			-- Categories Table
			CREATE TABLE Categories (
				CategoryId BIGINT IDENTITY(1,1) NOT NULL,
				CategoryName NVARCHAR(255) NOT NULL,
				Description NVARCHAR(MAX) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				ParentCategoryId BIGINT NULL,
				OrderBy INT DEFAULT 0 NOT NULL,
				Icon NVARCHAR(255) NULL,
				HasSubMenu BIT DEFAULT 0 NOT NULL,
				Link NVARCHAR(500) NULL,
				TenantId BIGINT NULL,
				MenuId BIGINT NULL,
				Created DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				Modified DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				ModifiedBy BIGINT NULL,
				CONSTRAINT PK_Categories PRIMARY KEY CLUSTERED (CategoryId),
				CONSTRAINT FK_Categories_ParentCategory FOREIGN KEY (ParentCategoryId) REFERENCES Categories(CategoryId),
				CONSTRAINT FK_Categories_Menu FOREIGN KEY (MenuId) REFERENCES MenuMaster(MenuId),
				CONSTRAINT FK_Categories_CreatedBy FOREIGN KEY (CreatedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_Categories_ModifiedBy FOREIGN KEY (ModifiedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_Categories_TenantName UNIQUE (TenantId, CategoryName)
			);

			-- Product Categories Table (Alternative structure for flexibility)
			CREATE TABLE ProductCategories (
				CategoryId BIGINT IDENTITY(1,1) NOT NULL,
				Category NVARCHAR(255) NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				OrderBy INT DEFAULT 0 NOT NULL,
				Description NVARCHAR(MAX) NULL,
				Icon NVARCHAR(255) NULL,
				SubMenu BIT DEFAULT 0 NOT NULL,
				TenantId BIGINT NULL,
				Created DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				Modified DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_ProductCategories PRIMARY KEY CLUSTERED (CategoryId)
			);

			-- Products Table - Core product information
			CREATE TABLE Products (
				ProductId BIGINT IDENTITY(1,1) NOT NULL,
				TenantId BIGINT NULL,
				ProductName NVARCHAR(255) NOT NULL,
				ProductDescription NVARCHAR(500) NULL,
				ProductCode NVARCHAR(100) NOT NULL,
				FullDescription NVARCHAR(MAX) NULL,
				Specification NVARCHAR(MAX) NULL,
				Story NVARCHAR(MAX) NULL,
				PackQuantity INT DEFAULT 1 NOT NULL,
				Quantity INT DEFAULT 0 NOT NULL,
				Total INT DEFAULT 0 NOT NULL,
				Price DECIMAL(18,2) NOT NULL,
				Category BIGINT NULL,
				Rating DECIMAL(3,2) DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				Trending INT DEFAULT 0 NOT NULL,
				UserBuyCount INT DEFAULT 0 NOT NULL,
				[Return] INT DEFAULT 30 NOT NULL, -- Return policy in days
				InStock BIT COMPUTED (CASE WHEN Quantity > 0 THEN 1 ELSE 0 END),
				BestSeller BIT DEFAULT 0 NOT NULL,
				DeliveryDate INT DEFAULT 7 NOT NULL, -- Delivery days
				Offer NVARCHAR(100) NULL,
				OrderBy INT DEFAULT 0 NOT NULL,
				UserId BIGINT NULL,
				Overview NVARCHAR(MAX) NULL,
				LongDescription NVARCHAR(MAX) NULL,
				-- SEO and Marketing
				MetaTitle NVARCHAR(255) NULL,
				MetaDescription NVARCHAR(500) NULL,
				MetaKeywords NVARCHAR(500) NULL,
				Slug NVARCHAR(255) NULL,
				-- Inventory Management
				SKU NVARCHAR(100) NULL,
				Barcode NVARCHAR(100) NULL,
				Weight DECIMAL(10,3) NULL,
				Dimensions NVARCHAR(100) NULL, -- L x W x H
				MinStockLevel INT DEFAULT 0 NOT NULL,
				MaxStockLevel INT NULL,
				ReorderPoint INT DEFAULT 0 NOT NULL,
				-- Pricing
				CostPrice DECIMAL(18,2) NULL,
				OriginalPrice DECIMAL(18,2) NULL,
				DiscountPercentage DECIMAL(5,2) DEFAULT 0 NOT NULL,
				-- Timestamps
				Created DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				Modified DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				ModifiedBy BIGINT NULL,
				DeletedAt DATETIME2(7) NULL,
				DeletedBy BIGINT NULL,
				CONSTRAINT PK_Products PRIMARY KEY CLUSTERED (ProductId),
				CONSTRAINT FK_Products_Category FOREIGN KEY (Category) REFERENCES Categories(CategoryId),
				CONSTRAINT FK_Products_CreatedBy FOREIGN KEY (CreatedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_Products_ModifiedBy FOREIGN KEY (ModifiedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_Products_DeletedBy FOREIGN KEY (DeletedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_Products_TenantCode UNIQUE (TenantId, ProductCode),
				CONSTRAINT UQ_Products_SKU UNIQUE (SKU),
				CONSTRAINT CK_Products_Price CHECK (Price >= 0),
				CONSTRAINT CK_Products_Quantity CHECK (Quantity >= 0),
				CONSTRAINT CK_Products_Rating CHECK (Rating >= 0 AND Rating <= 5),
				CONSTRAINT CK_Products_DiscountPercentage CHECK (DiscountPercentage >= 0 AND DiscountPercentage <= 100)
			);

			-- Product Images Table
			CREATE TABLE ProductImages (
				ImageId BIGINT IDENTITY(1,1) NOT NULL,
				ProductId BIGINT NOT NULL,
				ImageName NVARCHAR(255) NOT NULL,
				ContentType NVARCHAR(100) NOT NULL,
				FileSize BIGINT NOT NULL,
				ImageData VARBINARY(MAX) NULL,
				ThumbnailData VARBINARY(MAX) NULL,
				Poster NVARCHAR(500) NULL, -- URL/Path
				Main BIT DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				OrderBy INT DEFAULT 0 NOT NULL,
				AltText NVARCHAR(255) NULL,
				Caption NVARCHAR(500) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				Modified DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedBy BIGINT NULL,
				ModifiedBy BIGINT NULL,
				DeletedAt DATETIME2(7) NULL,
				DeletedBy BIGINT NULL,
				CONSTRAINT PK_ProductImages PRIMARY KEY CLUSTERED (ImageId),
				CONSTRAINT FK_ProductImages_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId) ON DELETE CASCADE,
				CONSTRAINT FK_ProductImages_CreatedBy FOREIGN KEY (CreatedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_ProductImages_ModifiedBy FOREIGN KEY (ModifiedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_ProductImages_DeletedBy FOREIGN KEY (DeletedBy) REFERENCES Users(UserId),
				CONSTRAINT CK_ProductImages_FileSize CHECK (FileSize > 0 AND FileSize <= 52428800) -- Max 50MB
			);

			-- Product Reviews Table
			CREATE TABLE ProductReviews (
				ReviewId BIGINT IDENTITY(1,1) NOT NULL,
				ProductId BIGINT NOT NULL,
				UserId BIGINT NOT NULL,
				Rating INT NOT NULL,
				ReviewTitle NVARCHAR(255) NULL,
				ReviewText NVARCHAR(MAX) NULL,
				IsVerifiedPurchase BIT DEFAULT 0 NOT NULL,
				IsApproved BIT DEFAULT 0 NOT NULL,
				HelpfulCount INT DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ApprovedAt DATETIME2(7) NULL,
				ApprovedBy BIGINT NULL,
				CONSTRAINT PK_ProductReviews PRIMARY KEY CLUSTERED (ReviewId),
				CONSTRAINT FK_ProductReviews_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId) ON DELETE CASCADE,
				CONSTRAINT FK_ProductReviews_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_ProductReviews_ApprovedBy FOREIGN KEY (ApprovedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_ProductReviews_UserProduct UNIQUE (UserId, ProductId),
				CONSTRAINT CK_ProductReviews_Rating CHECK (Rating >= 1 AND Rating <= 5)
			);

			-- Product Wishlist Table
			CREATE TABLE ProductWishList (
				WishListId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				ProductId BIGINT NOT NULL,
				TenantId BIGINT NULL,
				Priority INT DEFAULT 0 NOT NULL,
				Notes NVARCHAR(500) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_ProductWishList PRIMARY KEY CLUSTERED (WishListId),
				CONSTRAINT FK_ProductWishList_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_ProductWishList_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId) ON DELETE CASCADE,
				CONSTRAINT UQ_ProductWishList_UserProduct UNIQUE (UserId, ProductId)
			);

			-- ====================================== 
			-- SHOPPING CART TABLES
			-- ====================================== 

			-- Cart Items Table
			CREATE TABLE CartItems (
				CartId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				ProductId BIGINT NOT NULL,
				Quantity INT NOT NULL,
				TenantId BIGINT NULL,
				SessionId NVARCHAR(255) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				AddedDate DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedDate DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ExpiresAt DATETIME2(7) NULL, -- Cart expiration
				CONSTRAINT PK_CartItems PRIMARY KEY CLUSTERED (CartId),
				CONSTRAINT FK_CartItems_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_CartItems_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId) ON DELETE CASCADE,
				CONSTRAINT UQ_CartItems_UserProduct UNIQUE (UserId, ProductId, Active),
				CONSTRAINT CK_CartItems_Quantity CHECK (Quantity > 0)
			);

			-- ====================================== 
			-- ORDER MANAGEMENT TABLES
			-- ====================================== 

			-- Orders Table
			CREATE TABLE Orders (
				OrderId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				TenantId BIGINT NULL,
				OrderNumber NVARCHAR(50) NOT NULL,
				OrderStatus NVARCHAR(50) DEFAULT 'Pending' NOT NULL,
				PaymentStatus NVARCHAR(50) DEFAULT 'Pending' NOT NULL,
				TotalAmount DECIMAL(18,2) NOT NULL,
				Subtotal DECIMAL(18,2) NOT NULL,
				ShippingAmount DECIMAL(18,2) DEFAULT 0 NOT NULL,
				TaxAmount DECIMAL(18,2) DEFAULT 0 NOT NULL,
				DiscountAmount DECIMAL(18,2) DEFAULT 0 NOT NULL,
				CurrencyCode NVARCHAR(3) DEFAULT 'USD' NOT NULL,
				Notes NVARCHAR(1000) NULL,
				-- Address Information (JSON or normalized)
				ShippingAddress NVARCHAR(MAX) NULL, -- JSON
				BillingAddress NVARCHAR(MAX) NULL, -- JSON
				-- Payment and Shipping Information
				PaymentMethod NVARCHAR(MAX) NULL, -- JSON
				ShippingMethod NVARCHAR(MAX) NULL, -- JSON
				PaymentTransactionId NVARCHAR(255) NULL,
				ShippingTrackingNumber NVARCHAR(255) NULL,
				-- Important Timestamps
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ShippedAt DATETIME2(7) NULL,
				DeliveredAt DATETIME2(7) NULL,
				CancelledAt DATETIME2(7) NULL,
				-- Cancellation Information
				CancelReason NVARCHAR(500) NULL,
				CancelledBy BIGINT NULL,
				-- System Fields
				Active BIT DEFAULT 1 NOT NULL,
				CreatedBy BIGINT NULL,
				UpdatedBy BIGINT NULL,
				CONSTRAINT PK_Orders PRIMARY KEY CLUSTERED (OrderId),
				CONSTRAINT FK_Orders_Users FOREIGN KEY (UserId) REFERENCES Users(UserId),
				CONSTRAINT FK_Orders_CancelledBy FOREIGN KEY (CancelledBy) REFERENCES Users(UserId),
				CONSTRAINT FK_Orders_CreatedBy FOREIGN KEY (CreatedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_Orders_UpdatedBy FOREIGN KEY (UpdatedBy) REFERENCES Users(UserId),
				CONSTRAINT UQ_Orders_OrderNumber UNIQUE (OrderNumber),
				CONSTRAINT CK_Orders_TotalAmount CHECK (TotalAmount >= 0),
				CONSTRAINT CK_Orders_Subtotal CHECK (Subtotal >= 0),
				CONSTRAINT CK_Orders_ShippingAmount CHECK (ShippingAmount >= 0),
				CONSTRAINT CK_Orders_TaxAmount CHECK (TaxAmount >= 0),
				CONSTRAINT CK_Orders_DiscountAmount CHECK (DiscountAmount >= 0)
			);

			-- Order Items Table
			CREATE TABLE OrderItems (
				OrderItemId BIGINT IDENTITY(1,1) NOT NULL,
				OrderId BIGINT NOT NULL,
				ProductId BIGINT NOT NULL,
				ProductName NVARCHAR(255) NOT NULL,
				ProductImage NVARCHAR(500) NULL,
				ProductCode NVARCHAR(100) NULL,
				Price DECIMAL(18,2) NOT NULL,
				OriginalPrice DECIMAL(18,2) NULL,
				Quantity INT NOT NULL,
				Total DECIMAL(18,2) NOT NULL,
				DiscountAmount DECIMAL(18,2) DEFAULT 0 NOT NULL,
				TaxAmount DECIMAL(18,2) DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_OrderItems PRIMARY KEY CLUSTERED (OrderItemId),
				CONSTRAINT FK_OrderItems_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) ON DELETE CASCADE,
				CONSTRAINT FK_OrderItems_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId),
				CONSTRAINT CK_OrderItems_Price CHECK (Price >= 0),
				CONSTRAINT CK_OrderItems_Quantity CHECK (Quantity > 0),
				CONSTRAINT CK_OrderItems_Total CHECK (Total >= 0)
			);

			-- Order Status History Table
			CREATE TABLE OrderStatusHistory (
				StatusHistoryId BIGINT IDENTITY(1,1) NOT NULL,
				OrderId BIGINT NOT NULL,
				PreviousStatus NVARCHAR(50) NULL,
				NewStatus NVARCHAR(50) NOT NULL,
				StatusNote NVARCHAR(1000) NULL,
				ChangedBy BIGINT NULL,
				ChangedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_OrderStatusHistory PRIMARY KEY CLUSTERED (StatusHistoryId),
				CONSTRAINT FK_OrderStatusHistory_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) ON DELETE CASCADE,
				CONSTRAINT FK_OrderStatusHistory_ChangedBy FOREIGN KEY (ChangedBy) REFERENCES Users(UserId)
			);

			-- Order Tracking Table
			CREATE TABLE OrderTracking (
				TrackingId BIGINT IDENTITY(1,1) NOT NULL,
				OrderId BIGINT NOT NULL,
				TrackingNumber NVARCHAR(100) NULL,
				Carrier NVARCHAR(100) NULL,
				TrackingStatus NVARCHAR(50) DEFAULT 'Pending' NOT NULL,
				EstimatedDelivery DATETIME2(7) NULL,
				ActualDelivery DATETIME2(7) NULL,
				TrackingUrl NVARCHAR(500) NULL,
				ShippingCost DECIMAL(18,2) NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_OrderTracking PRIMARY KEY CLUSTERED (TrackingId),
				CONSTRAINT FK_OrderTracking_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) ON DELETE CASCADE,
				CONSTRAINT UQ_OrderTracking_OrderActive UNIQUE (OrderId, Active)
			);

			-- Order Refunds Table
			CREATE TABLE OrderRefunds (
				RefundId BIGINT IDENTITY(1,1) NOT NULL,
				OrderId BIGINT NOT NULL,
				RefundAmount DECIMAL(18,2) NOT NULL,
				RefundReason NVARCHAR(500) NULL,
				RefundStatus NVARCHAR(50) DEFAULT 'Pending' NOT NULL,
				RefundMethod NVARCHAR(100) NULL,
				RefundTransactionId NVARCHAR(255) NULL,
				RequestedBy BIGINT NOT NULL,
				RequestedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				ProcessedAt DATETIME2(7) NULL,
				ProcessedBy BIGINT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_OrderRefunds PRIMARY KEY CLUSTERED (RefundId),
				CONSTRAINT FK_OrderRefunds_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) ON DELETE CASCADE,
				CONSTRAINT FK_OrderRefunds_RequestedBy FOREIGN KEY (RequestedBy) REFERENCES Users(UserId),
				CONSTRAINT FK_OrderRefunds_ProcessedBy FOREIGN KEY (ProcessedBy) REFERENCES Users(UserId),
				CONSTRAINT CK_OrderRefunds_RefundAmount CHECK (RefundAmount >= 0)
			);

			-- Order Analytics Table
			CREATE TABLE OrderAnalytics (
				AnalyticsId BIGINT IDENTITY(1,1) NOT NULL,
				OrderId BIGINT NOT NULL,
				UserId BIGINT NOT NULL,
				OrderNumber NVARCHAR(50) NOT NULL,
				TotalAmount DECIMAL(18,2) NOT NULL,
				ItemCount INT NOT NULL,
				OrderDate DATETIME2(7) NOT NULL,
				TenantId BIGINT NULL,
				OrderSource NVARCHAR(50) DEFAULT 'Web' NULL, -- Web, Mobile, API
				DeviceType NVARCHAR(50) NULL,
				UserAgent NVARCHAR(500) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_OrderAnalytics PRIMARY KEY CLUSTERED (AnalyticsId),
				CONSTRAINT FK_OrderAnalytics_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId) ON DELETE CASCADE,
				CONSTRAINT FK_OrderAnalytics_Users FOREIGN KEY (UserId) REFERENCES Users(UserId)
			);

			-- ====================================== 
			-- USER MANAGEMENT TABLES
			-- ====================================== 

			-- User Addresses Table
			CREATE TABLE UserAddresses (
				AddressId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				AddressType NVARCHAR(50) DEFAULT 'Home' NOT NULL, -- Home, Work, Shipping, Billing
				Street NVARCHAR(255) NOT NULL,
				City NVARCHAR(100) NOT NULL,
				State NVARCHAR(100) NOT NULL,
				PostalCode NVARCHAR(20) NOT NULL,
				Country NVARCHAR(100) NOT NULL,
				IsDefault BIT DEFAULT 0 NOT NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserAddresses PRIMARY KEY CLUSTERED (AddressId),
				CONSTRAINT FK_UserAddresses_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE
			);

			-- User Preferences Table
			CREATE TABLE UserPreferences (
				PreferenceId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				PreferenceKey NVARCHAR(100) NOT NULL,
				PreferenceValue NVARCHAR(MAX) NULL,
				PreferenceType NVARCHAR(50) DEFAULT 'String' NOT NULL, -- String, Number, Boolean, JSON
				Category NVARCHAR(100) DEFAULT 'General' NULL,
				Active BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserPreferences PRIMARY KEY CLUSTERED (PreferenceId),
				CONSTRAINT FK_UserPreferences_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE,
				CONSTRAINT UQ_UserPreferences_UserKey UNIQUE (UserId, PreferenceKey)
			);

			-- User Tokens Table
			CREATE TABLE UserTokens (
				TokenId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				Token NVARCHAR(MAX) NOT NULL,
				RefreshToken NVARCHAR(MAX) NULL,
				TokenType NVARCHAR(50) DEFAULT 'JWT' NOT NULL,
				DeviceId NVARCHAR(255) NULL,
				DeviceInfo NVARCHAR(500) NULL,
				IpAddress NVARCHAR(45) NULL,
				UserAgent NVARCHAR(500) NULL,
				ExpiresAt DATETIME2(7) NOT NULL,
				IsRevoked BIT DEFAULT 0 NOT NULL,
				RevokedAt DATETIME2(7) NULL,
				RevokedReason NVARCHAR(255) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserTokens PRIMARY KEY CLUSTERED (TokenId),
				CONSTRAINT FK_UserTokens_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE
			);

			-- User Sessions Table
			CREATE TABLE UserSessions (
				SessionId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				SessionToken NVARCHAR(255) NOT NULL,
				DeviceId NVARCHAR(255) NULL,
				IpAddress NVARCHAR(45) NULL,
				UserAgent NVARCHAR(500) NULL,
				LoginAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				LastActivityAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				LoggedOutAt DATETIME2(7) NULL,
				ExpiresAt DATETIME2(7) NOT NULL,
				IsActive BIT DEFAULT 1 NOT NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserSessions PRIMARY KEY CLUSTERED (SessionId),
				CONSTRAINT FK_UserSessions_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE,
				CONSTRAINT UQ_UserSessions_SessionToken UNIQUE (SessionToken)
			);

			-- Password Reset Tokens Table
			CREATE TABLE PasswordResetTokens (
				ResetTokenId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				ResetToken NVARCHAR(255) NOT NULL,
				ExpiresAt DATETIME2(7) NOT NULL,
				IsUsed BIT DEFAULT 0 NOT NULL,
				UsedAt DATETIME2(7) NULL,
				IpAddress NVARCHAR(45) NULL,
				UserAgent NVARCHAR(500) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_PasswordResetTokens PRIMARY KEY CLUSTERED (ResetTokenId),
				CONSTRAINT FK_PasswordResetTokens_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE,
				CONSTRAINT UQ_PasswordResetTokens_Token UNIQUE (ResetToken)
			);

			-- User Activity Log Table
			CREATE TABLE UserActivityLog (
				ActivityLogId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				ActivityType NVARCHAR(100) NOT NULL,
				ActivityDescription NVARCHAR(MAX) NULL,
				IpAddress NVARCHAR(45) NULL,
				UserAgent NVARCHAR(500) NULL,
				DeviceId NVARCHAR(255) NULL,
				ResourceType NVARCHAR(50) NULL, -- Product, Order, User, etc.
				ResourceId BIGINT NULL,
				SessionId NVARCHAR(255) NULL,
				PerformedBy BIGINT NULL, -- For admin actions
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserActivityLog PRIMARY KEY CLUSTERED (ActivityLogId),
				CONSTRAINT FK_UserActivityLog_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE,
				CONSTRAINT FK_UserActivityLog_PerformedBy FOREIGN KEY (PerformedBy) REFERENCES Users(UserId)
			);

			-- User Notifications Table
			CREATE TABLE UserNotifications (
				NotificationId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				NotificationType NVARCHAR(50) NOT NULL,
				Title NVARCHAR(255) NOT NULL,
				Message NVARCHAR(MAX) NOT NULL,
				IsRead BIT DEFAULT 0 NOT NULL,
				ReadAt DATETIME2(7) NULL,
				Priority NVARCHAR(20) DEFAULT 'Normal' NOT NULL, -- Low, Normal, High, Critical
				ExpiresAt DATETIME2(7) NULL,
				ActionUrl NVARCHAR(500) NULL,
				ActionText NVARCHAR(100) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserNotifications PRIMARY KEY CLUSTERED (NotificationId),
				CONSTRAINT FK_UserNotifications_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE
			);

			-- Notification Queue Table
			CREATE TABLE NotificationQueue (
				QueueId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				NotificationType NVARCHAR(50) NOT NULL,
				Subject NVARCHAR(255) NOT NULL,
				Message NVARCHAR(MAX) NOT NULL,
				OrderId BIGINT NULL,
				ProductId BIGINT NULL,
				Priority NVARCHAR(20) DEFAULT 'Normal' NOT NULL,
				Status NVARCHAR(50) DEFAULT 'Pending' NOT NULL, -- Pending, Sent, Failed
				ScheduledAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				SentAt DATETIME2(7) NULL,
				AttemptCount INT DEFAULT 0 NOT NULL,
				LastAttemptAt DATETIME2(7) NULL,
				ErrorMessage NVARCHAR(MAX) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				UpdatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_NotificationQueue PRIMARY KEY CLUSTERED (QueueId),
				CONSTRAINT FK_NotificationQueue_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE,
				CONSTRAINT FK_NotificationQueue_Orders FOREIGN KEY (OrderId) REFERENCES Orders(OrderId),
				CONSTRAINT FK_NotificationQueue_Products FOREIGN KEY (ProductId) REFERENCES Products(ProductId)
			);

			-- User Behavior Analytics Table
			CREATE TABLE UserBehaviorAnalytics (
				BehaviorId BIGINT IDENTITY(1,1) NOT NULL,
				UserId BIGINT NOT NULL,
				ActionType NVARCHAR(100) NOT NULL,
				ActionDetails NVARCHAR(MAX) NULL,
				ItemCount INT NULL,
				TotalValue DECIMAL(18,2) NULL,
				SessionId NVARCHAR(255) NULL,
				IpAddress NVARCHAR(45) NULL,
				UserAgent NVARCHAR(500) NULL,
				DeviceType NVARCHAR(50) NULL,
				ReferrerUrl NVARCHAR(500) NULL,
				CreatedAt DATETIME2(7) DEFAULT GETUTCDATE() NOT NULL,
				CONSTRAINT PK_UserBehaviorAnalytics PRIMARY KEY CLUSTERED (BehaviorId),
				CONSTRAINT FK_UserBehaviorAnalytics_Users FOREIGN KEY (UserId) REFERENCES Users(UserId) ON DELETE CASCADE
			);
		]]>
	</query>
	
	<query Id="CREATE_OPTIMIZED_INDEXES">
		<![CDATA[
			-- ====================================== 
			-- OPTIMIZED INDEX CREATION
			-- Performance-focused indexing strategy
			-- ====================================== 
			
			-- ====================================== 
			-- USERS TABLE INDEXES
			-- ====================================== 
			
			-- Primary lookup indexes
			CREATE NONCLUSTERED INDEX IX_Users_Email ON Users (Email) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Users_Phone ON Users (Phone) WHERE Active = 1 AND Phone IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_Users_TenantId ON Users (TenantId, Active, UserId);
			CREATE NONCLUSTERED INDEX IX_Users_LastLogin ON Users (LastLogin DESC) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Users_CreatedAt ON Users (CreatedAt DESC);
			
			-- Authentication and security indexes
			CREATE NONCLUSTERED INDEX IX_Users_LoginAttempts ON Users (AccountLocked, LoginAttempts, LastLoginAttempt) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Users_EmailVerification ON Users (EmailVerified, PhoneVerified, Active);
			
			-- Admin and reporting indexes
			CREATE NONCLUSTERED INDEX IX_Users_ActiveStatus ON Users (Active, AccountLocked, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_Users_ProfileCompletion ON Users (DateOfBirth, Gender, Country, City) WHERE Active = 1;

			-- ====================================== 
			-- PRODUCTS TABLE INDEXES
			-- ====================================== 
			
			-- Primary product lookups
			CREATE NONCLUSTERED INDEX IX_Products_TenantId_Active ON Products (TenantId, Active, ProductId);
			CREATE NONCLUSTERED INDEX IX_Products_ProductCode ON Products (ProductCode, TenantId) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Products_Category ON Products (Category, Active, Price, Rating DESC);
			CREATE NONCLUSTERED INDEX IX_Products_SKU ON Products (SKU) WHERE Active = 1 AND SKU IS NOT NULL;
			
			-- Search and filtering indexes
			CREATE NONCLUSTERED INDEX IX_Products_Search ON Products (TenantId, Active) INCLUDE (ProductName, ProductDescription, ProductCode, Price, Rating);
			CREATE NONCLUSTERED INDEX IX_Products_Price ON Products (TenantId, Active, Price ASC);
			CREATE NONCLUSTERED INDEX IX_Products_Rating ON Products (TenantId, Active, Rating DESC);
			CREATE NONCLUSTERED INDEX IX_Products_Stock ON Products (TenantId, Active, Quantity DESC);
			CREATE NONCLUSTERED INDEX IX_Products_BestSeller ON Products (TenantId, Active, BestSeller DESC, UserBuyCount DESC);
			CREATE NONCLUSTERED INDEX IX_Products_Trending ON Products (TenantId, Active, Trending DESC, Created DESC);
			
			-- Sorting and ordering indexes
			CREATE NONCLUSTERED INDEX IX_Products_Created ON Products (TenantId, Active, Created DESC);
			CREATE NONCLUSTERED INDEX IX_Products_Modified ON Products (TenantId, Active, Modified DESC);
			CREATE NONCLUSTERED INDEX IX_Products_UserBuyCount ON Products (TenantId, Active, UserBuyCount DESC);
			CREATE NONCLUSTERED INDEX IX_Products_OrderBy ON Products (TenantId, Active, OrderBy ASC, ProductName ASC);
			
			-- Inventory management indexes
			CREATE NONCLUSTERED INDEX IX_Products_Inventory ON Products (Active, Quantity, MinStockLevel, ReorderPoint) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Products_LowStock ON Products (Active, MinStockLevel, Quantity) WHERE Active = 1 AND Quantity <= MinStockLevel;

			-- ====================================== 
			-- PRODUCT IMAGES TABLE INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_ProductImages_ProductId ON ProductImages (ProductId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_ProductImages_Main ON ProductImages (ProductId, Main DESC, Active) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_ProductImages_Active ON ProductImages (Active, CreatedAt DESC);

			-- ====================================== 
			-- CATEGORIES TABLE INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_Categories_TenantId ON Categories (TenantId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_Categories_ParentId ON Categories (ParentCategoryId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_Categories_MenuId ON Categories (MenuId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_Categories_Name ON Categories (CategoryName, TenantId) WHERE Active = 1;

			-- ====================================== 
			-- ORDERS TABLE INDEXES
			-- ====================================== 
			
			-- Primary order lookups
			CREATE NONCLUSTERED INDEX IX_Orders_UserId ON Orders (UserId, Active, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_Orders_OrderNumber ON Orders (OrderNumber) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Orders_TenantId ON Orders (TenantId, Active, CreatedAt DESC);
			
			-- Status and payment indexes
			CREATE NONCLUSTERED INDEX IX_Orders_Status ON Orders (OrderStatus, Active, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_Orders_PaymentStatus ON Orders (PaymentStatus, Active, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_Orders_StatusPayment ON Orders (OrderStatus, PaymentStatus, Active);
			
			-- Date-based indexes for reporting
			CREATE NONCLUSTERED INDEX IX_Orders_CreatedAt ON Orders (CreatedAt DESC, Active) INCLUDE (TotalAmount, OrderStatus, PaymentStatus);
			CREATE NONCLUSTERED INDEX IX_Orders_UpdatedAt ON Orders (UpdatedAt DESC) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Orders_ShippedAt ON Orders (ShippedAt DESC) WHERE ShippedAt IS NOT NULL AND Active = 1;
			CREATE NONCLUSTERED INDEX IX_Orders_DeliveredAt ON Orders (DeliveredAt DESC) WHERE DeliveredAt IS NOT NULL AND Active = 1;
			
			-- Admin and analytics indexes
			CREATE NONCLUSTERED INDEX IX_Orders_TotalAmount ON Orders (TotalAmount DESC, CreatedAt DESC) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Orders_Analytics ON Orders (TenantId, OrderStatus, PaymentStatus, CreatedAt DESC) INCLUDE (TotalAmount, UserId);

			-- ====================================== 
			-- ORDER ITEMS TABLE INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_OrderItems_OrderId ON OrderItems (OrderId, Active);
			CREATE NONCLUSTERED INDEX IX_OrderItems_ProductId ON OrderItems (ProductId, Active, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_OrderItems_OrderProduct ON OrderItems (OrderId, ProductId) WHERE Active = 1;

			-- ====================================== 
			-- CART ITEMS TABLE INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_CartItems_UserId ON CartItems (UserId, Active, AddedDate DESC);
			CREATE NONCLUSTERED INDEX IX_CartItems_ProductId ON CartItems (ProductId, Active);
			CREATE NONCLUSTERED INDEX IX_CartItems_TenantId ON CartItems (TenantId, Active) WHERE TenantId IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_CartItems_SessionId ON CartItems (SessionId, Active) WHERE SessionId IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_CartItems_UserProduct ON CartItems (UserId, ProductId, Active);
			CREATE NONCLUSTERED INDEX IX_CartItems_Expiration ON CartItems (ExpiresAt ASC) WHERE ExpiresAt IS NOT NULL AND Active = 1;

			-- ====================================== 
			-- USER ROLES AND PERMISSIONS INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_UserRoles_UserId ON UserRoles (UserId, Active);
			CREATE NONCLUSTERED INDEX IX_UserRoles_RoleId ON UserRoles (RoleId, Active);
			CREATE NONCLUSTERED INDEX IX_UserRoles_AssignedBy ON UserRoles (AssignedBy, AssignedAt DESC) WHERE AssignedBy IS NOT NULL;
			
			CREATE NONCLUSTERED INDEX IX_RolePermissions_RoleId ON RolePermissions (RoleId, Active);
			CREATE NONCLUSTERED INDEX IX_RolePermissions_PermissionId ON RolePermissions (PermissionId, Active);
			
			CREATE NONCLUSTERED INDEX IX_UserCustomPermissions_UserId ON UserCustomPermissions (UserId, Active);
			CREATE NONCLUSTERED INDEX IX_UserCustomPermissions_PermissionId ON UserCustomPermissions (PermissionId, Active);

			-- ====================================== 
			-- ACTIVITY AND LOGGING INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_UserId ON UserActivityLog (UserId, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_ActivityType ON UserActivityLog (ActivityType, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_ResourceType ON UserActivityLog (ResourceType, ResourceId, CreatedAt DESC) WHERE ResourceType IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_PerformedBy ON UserActivityLog (PerformedBy, CreatedAt DESC) WHERE PerformedBy IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_CreatedAt ON UserActivityLog (CreatedAt DESC) INCLUDE (UserId, ActivityType, ActivityDescription);

			-- ====================================== 
			-- ORDER TRACKING AND HISTORY INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_OrderStatusHistory_OrderId ON OrderStatusHistory (OrderId, ChangedAt DESC);
			CREATE NONCLUSTERED INDEX IX_OrderStatusHistory_ChangedBy ON OrderStatusHistory (ChangedBy, ChangedAt DESC) WHERE ChangedBy IS NOT NULL;
			
			CREATE NONCLUSTERED INDEX IX_OrderTracking_OrderId ON OrderTracking (OrderId, Active);
			CREATE NONCLUSTERED INDEX IX_OrderTracking_TrackingNumber ON OrderTracking (TrackingNumber) WHERE TrackingNumber IS NOT NULL AND Active = 1;
			CREATE NONCLUSTERED INDEX IX_OrderTracking_Status ON OrderTracking (TrackingStatus, UpdatedAt DESC) WHERE Active = 1;
			
			CREATE NONCLUSTERED INDEX IX_OrderRefunds_OrderId ON OrderRefunds (OrderId, Active);
			CREATE NONCLUSTERED INDEX IX_OrderRefunds_Status ON OrderRefunds (RefundStatus, RequestedAt DESC) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_OrderRefunds_RequestedBy ON OrderRefunds (RequestedBy, RequestedAt DESC);

			-- ====================================== 
			-- NOTIFICATIONS AND QUEUE INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_UserNotifications_UserId ON UserNotifications (UserId, IsRead, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserNotifications_Type ON UserNotifications (NotificationType, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserNotifications_Unread ON UserNotifications (UserId, IsRead, Priority DESC, CreatedAt DESC) WHERE IsRead = 0;
			
			CREATE NONCLUSTERED INDEX IX_NotificationQueue_Status ON NotificationQueue (Status, ScheduledAt ASC) WHERE Status = 'Pending';
			CREATE NONCLUSTERED INDEX IX_NotificationQueue_UserId ON NotificationQueue (UserId, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_NotificationQueue_Type ON NotificationQueue (NotificationType, Status, CreatedAt DESC);

			-- ====================================== 
			-- ANALYTICS AND REPORTING INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_OrderAnalytics_UserId ON OrderAnalytics (UserId, OrderDate DESC);
			CREATE NONCLUSTERED INDEX IX_OrderAnalytics_TenantId ON OrderAnalytics (TenantId, OrderDate DESC) WHERE TenantId IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_OrderAnalytics_OrderDate ON OrderAnalytics (OrderDate DESC) INCLUDE (TotalAmount, ItemCount, UserId);
			CREATE NONCLUSTERED INDEX IX_OrderAnalytics_OrderSource ON OrderAnalytics (OrderSource, OrderDate DESC) WHERE OrderSource IS NOT NULL;
			
			CREATE NONCLUSTERED INDEX IX_UserBehaviorAnalytics_UserId ON UserBehaviorAnalytics (UserId, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserBehaviorAnalytics_ActionType ON UserBehaviorAnalytics (ActionType, CreatedAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserBehaviorAnalytics_SessionId ON UserBehaviorAnalytics (SessionId, CreatedAt DESC) WHERE SessionId IS NOT NULL;

			-- ====================================== 
			-- USER MANAGEMENT INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_UserAddresses_UserId ON UserAddresses (UserId, Active, IsDefault DESC);
			CREATE NONCLUSTERED INDEX IX_UserAddresses_Type ON UserAddresses (UserId, AddressType, Active);
			
			CREATE NONCLUSTERED INDEX IX_UserPreferences_UserId ON UserPreferences (UserId, Active, Category);
			CREATE NONCLUSTERED INDEX IX_UserPreferences_Key ON UserPreferences (PreferenceKey, Active);
			
			CREATE NONCLUSTERED INDEX IX_UserTokens_UserId ON UserTokens (UserId, IsRevoked, ExpiresAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserTokens_DeviceId ON UserTokens (DeviceId, IsRevoked) WHERE DeviceId IS NOT NULL;
			CREATE NONCLUSTERED INDEX IX_UserTokens_ExpiresAt ON UserTokens (ExpiresAt ASC, IsRevoked) WHERE IsRevoked = 0;
			
			CREATE NONCLUSTERED INDEX IX_UserSessions_UserId ON UserSessions (UserId, IsActive, LastActivityAt DESC);
			CREATE NONCLUSTERED INDEX IX_UserSessions_SessionToken ON UserSessions (SessionToken, IsActive);
			CREATE NONCLUSTERED INDEX IX_UserSessions_DeviceId ON UserSessions (DeviceId, IsActive) WHERE DeviceId IS NOT NULL;
			
			CREATE NONCLUSTERED INDEX IX_PasswordResetTokens_UserId ON PasswordResetTokens (UserId, IsUsed, ExpiresAt DESC);
			CREATE NONCLUSTERED INDEX IX_PasswordResetTokens_Token ON PasswordResetTokens (ResetToken, IsUsed, ExpiresAt);

			-- ====================================== 
			-- MENU AND CATEGORIES INDEXES
			-- ====================================== 
			
			CREATE NONCLUSTERED INDEX IX_MenuMaster_TenantId ON MenuMaster (TenantId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_MenuMaster_OrderBy ON MenuMaster (OrderBy ASC, MenuName ASC) WHERE Active = 1;
			
			CREATE NONCLUSTERED INDEX IX_Categories_TenantId_Active ON Categories (TenantId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_Categories_ParentId_Active ON Categories (ParentCategoryId, Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_Categories_MenuId_Active ON Categories (MenuId, Active, OrderBy ASC) WHERE MenuId IS NOT NULL;
			
			CREATE NONCLUSTERED INDEX IX_ProductCategories_Active ON ProductCategories (Active, OrderBy ASC);
			CREATE NONCLUSTERED INDEX IX_ProductCategories_TenantId ON ProductCategories (TenantId, Active) WHERE TenantId IS NOT NULL;

			-- ====================================== 
			-- PERFORMANCE OPTIMIZATION INDEXES
			-- ====================================== 
			
			-- Composite indexes for complex queries
			CREATE NONCLUSTERED INDEX IX_Products_SearchFilter ON Products (TenantId, Active, Category, BestSeller, Rating DESC) 
				INCLUDE (ProductId, ProductName, Price, Quantity, UserBuyCount, Offer);
			
			CREATE NONCLUSTERED INDEX IX_Products_PriceRange ON Products (TenantId, Active, Price ASC) 
				INCLUDE (ProductId, ProductName, Category, Rating, BestSeller);
			
			CREATE NONCLUSTERED INDEX IX_Orders_UserStatus ON Orders (UserId, OrderStatus, Active, CreatedAt DESC) 
				INCLUDE (OrderId, OrderNumber, TotalAmount, PaymentStatus);
			
			CREATE NONCLUSTERED INDEX IX_Orders_AdminView ON Orders (TenantId, OrderStatus, CreatedAt DESC) 
				INCLUDE (OrderId, OrderNumber, UserId, TotalAmount, PaymentStatus, ItemCount);
			
			-- Cart optimization indexes
			CREATE NONCLUSTERED INDEX IX_CartItems_UserTenant ON CartItems (UserId, TenantId, Active, AddedDate DESC) 
				INCLUDE (ProductId, Quantity);
			
			-- Analytics optimization indexes
			CREATE NONCLUSTERED INDEX IX_UserActivityLog_Analytics ON UserActivityLog (UserId, ActivityType, CreatedAt DESC) 
				WHERE ActivityType IN ('LOGIN', 'ORDER_CREATED', 'PRODUCT_VIEW', 'CART_ADD');

			-- ====================================== 
			-- FULL-TEXT SEARCH INDEXES (Optional - for advanced search)
			-- ====================================== 
			
			-- Enable full-text search on products
			-- CREATE FULLTEXT CATALOG ProductSearchCatalog;
			-- CREATE FULLTEXT INDEX ON Products (ProductName, ProductDescription, FullDescription, Overview, LongDescription)
			--     KEY INDEX PK_Products ON ProductSearchCatalog;

			-- ====================================== 
			-- COMPUTED COLUMNS AND CONSTRAINTS
			-- ====================================== 
			
			-- Add computed columns for better performance
			ALTER TABLE Products ADD FullName AS (ProductName + ' ' + ISNULL(ProductCode, '')) PERSISTED;
			ALTER TABLE Products ADD PriceWithDiscount AS (Price * (1 - DiscountPercentage / 100)) PERSISTED;
			ALTER TABLE Users ADD FullName AS (FirstName + ' ' + LastName) PERSISTED;
			ALTER TABLE Orders ADD OrderAge AS DATEDIFF(DAY, CreatedAt, GETUTCDATE()) PERSISTED;

			-- Create indexes on computed columns
			CREATE NONCLUSTERED INDEX IX_Products_FullName ON Products (FullName) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Products_PriceWithDiscount ON Products (TenantId, Active, PriceWithDiscount ASC);
			CREATE NONCLUSTERED INDEX IX_Users_FullName ON Users (FullName) WHERE Active = 1;
			CREATE NONCLUSTERED INDEX IX_Orders_OrderAge ON Orders (OrderAge ASC, OrderStatus) WHERE Active = 1;
		]]>
	</query>
	
	<query Id="INSERT_SEED_DATA">
		<![CDATA[
			C	
		]]>
	</query>
	
	<query Id="CREATE_MAINTENANCE_PROCEDURES">
		<![CDATA[
			-- ====================================== 
			-- DATABASE MAINTENANCE PROCEDURES
			-- Performance and housekeeping operations
			-- ====================================== 
			
			-- Procedure to clean up expired data
			CREATE OR ALTER PROCEDURE [dbo].[SP_CLEANUP_EXPIRED_DATA]
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					DECLARE @CleanupDate DATETIME2(7) = GETUTCDATE();
					DECLARE @DeletedCount INT = 0;
					
					-- Clean up expired password reset tokens (older than 24 hours)
					DELETE FROM PasswordResetTokens 
					WHERE ExpiresAt < @CleanupDate OR (IsUsed = 1 AND UsedAt < DATEADD(DAY, -7, @CleanupDate));
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up expired user sessions (older than 30 days)
					DELETE FROM UserSessions 
					WHERE ExpiresAt < @CleanupDate OR (IsActive = 0 AND LoggedOutAt < DATEADD(DAY, -30, @CleanupDate));
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up old user tokens (expired and revoked tokens older than 30 days)
					DELETE FROM UserTokens 
					WHERE (ExpiresAt < @CleanupDate OR IsRevoked = 1) AND CreatedAt < DATEADD(DAY, -30, @CleanupDate);
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up old cart items (inactive items older than 90 days)
					DELETE FROM CartItems 
					WHERE Active = 0 AND UpdatedDate < DATEADD(DAY, -90, @CleanupDate);
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up expired cart items (based on ExpiresAt)
					UPDATE CartItems 
					SET Active = 0, UpdatedDate = @CleanupDate
					WHERE ExpiresAt < @CleanupDate AND Active = 1;
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up old user activity logs (older than 1 year)
					DELETE FROM UserActivityLog 
					WHERE CreatedAt < DATEADD(YEAR, -1, @CleanupDate);
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up processed notifications (older than 30 days)
					DELETE FROM NotificationQueue 
					WHERE Status = 'Sent' AND SentAt < DATEADD(DAY, -30, @CleanupDate);
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					-- Clean up old user behavior analytics (older than 2 years)
					DELETE FROM UserBehaviorAnalytics 
					WHERE CreatedAt < DATEADD(YEAR, -2, @CleanupDate);
					SET @DeletedCount = @DeletedCount + @@ROWCOUNT;
					
					PRINT 'Cleanup completed. Total records cleaned: ' + CAST(@DeletedCount AS VARCHAR(10));
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					PRINT 'Cleanup failed: ' + @ErrorMessage;
					THROW;
				END CATCH
			END;
			
			-- Procedure to update product statistics
			CREATE OR ALTER PROCEDURE [dbo].[SP_UPDATE_PRODUCT_STATISTICS]
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Update product ratings based on reviews
					UPDATE p
					SET Rating = ISNULL(avgRating.AvgRating, 0),
						Modified = GETUTCDATE()
					FROM Products p
					LEFT JOIN (
						SELECT 
							ProductId,
							AVG(CAST(Rating AS DECIMAL(3,2))) AS AvgRating
						FROM ProductReviews 
						WHERE Active = 1 AND IsApproved = 1
						GROUP BY ProductId
					) avgRating ON p.ProductId = avgRating.ProductId
					WHERE p.Active = 1;
					
					-- Update best seller flags based on sales
					UPDATE Products
					SET BestSeller = CASE 
						WHEN UserBuyCount >= (
							SELECT AVG(UserBuyCount) * 1.5 
							FROM Products 
							WHERE Active = 1 AND TenantId = Products.TenantId
						) THEN 1 
						ELSE 0 
					END,
					Modified = GETUTCDATE()
					WHERE Active = 1;
					
					-- Update trending products (based on recent sales)
					UPDATE p
					SET Trending = CASE 
						WHEN recentSales.RecentCount >= 5 THEN 1 
						ELSE 0 
					END,
					Modified = GETUTCDATE()
					FROM Products p
					LEFT JOIN (
						SELECT 
							oi.ProductId,
							COUNT(*) AS RecentCount
						FROM OrderItems oi
						INNER JOIN Orders o ON oi.OrderId = o.OrderId
						WHERE o.CreatedAt >= DATEADD(DAY, -7, GETUTCDATE())
							AND o.Active = 1 AND oi.Active = 1
						GROUP BY oi.ProductId
					) recentSales ON p.ProductId = recentSales.ProductId
					WHERE p.Active = 1;
					
					PRINT 'Product statistics updated successfully.';
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					PRINT 'Product statistics update failed: ' + @ErrorMessage;
					THROW;
				END CATCH
			END;
			
			-- Procedure to rebuild indexes for performance
			CREATE OR ALTER PROCEDURE [dbo].[SP_REBUILD_INDEXES]
				@TableName NVARCHAR(255) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				DECLARE @SQL NVARCHAR(MAX);
				DECLARE @IndexName NVARCHAR(255);
				DECLARE @SchemaName NVARCHAR(255) = 'dbo';
				
				DECLARE index_cursor CURSOR FOR
				SELECT 
					t.name AS TableName,
					i.name AS IndexName
				FROM sys.tables t
				INNER JOIN sys.indexes i ON t.object_id = i.object_id
				WHERE i.type > 0 -- Exclude heaps
					AND (@TableName IS NULL OR t.name = @TableName)
					AND t.name IN (
						'Users', 'Products', 'Orders', 'OrderItems', 'CartItems', 
						'ProductImages', 'Categories', 'UserActivityLog', 'OrderAnalytics'
					);
				
				OPEN index_cursor;
				FETCH NEXT FROM index_cursor INTO @TableName, @IndexName;
				
				WHILE @@FETCH_STATUS = 0
				BEGIN
					SET @SQL = 'ALTER INDEX ' + QUOTENAME(@IndexName) + ' ON ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + ' REBUILD WITH (ONLINE = OFF, SORT_IN_TEMPDB = ON);';
					
					BEGIN TRY
						EXEC sp_executesql @SQL;
						PRINT 'Rebuilt index: ' + @IndexName + ' on table: ' + @TableName;
					END TRY
					BEGIN CATCH
						PRINT 'Failed to rebuild index: ' + @IndexName + ' on table: ' + @TableName + ' - ' + ERROR_MESSAGE();
					END CATCH
					
					FETCH NEXT FROM index_cursor INTO @TableName, @IndexName;
				END
				
				CLOSE index_cursor;
				DEALLOCATE index_cursor;
				
				PRINT 'Index rebuild completed.';
			END;
		]]>
	</query>
	
	<query Id="CREATE_PERFORMANCE_VIEWS">
		<![CDATA[
			-- ====================================== 
			-- PERFORMANCE MONITORING VIEWS
			-- Business intelligence and reporting views
			-- ====================================== 
			
			-- Product Performance View
			CREATE OR ALTER VIEW [dbo].[VW_PRODUCT_PERFORMANCE]
			AS
			SELECT 
				p.ProductId,
				p.TenantId,
				p.ProductName,
				p.ProductCode,
				p.Price,
				p.PriceWithDiscount,
				p.Quantity AS StockLevel,
				p.Rating,
				p.UserBuyCount AS TotalSales,
				p.BestSeller,
				p.Trending,
				p.Active,
				c.CategoryName,
				-- Performance metrics
				ISNULL(recentSales.Last30Days, 0) AS SalesLast30Days,
				ISNULL(revenue.TotalRevenue, 0) AS TotalRevenue,
				ISNULL(reviews.ReviewCount, 0) AS ReviewCount,
				ISNULL(reviews.AvgRating, 0) AS AverageRating,
				ISNULL(cart.InCartCount, 0) AS CurrentlyInCarts,
				ISNULL(wishlist.WishlistCount, 0) AS InWishlists,
				-- Inventory alerts
				CASE 
					WHEN p.Quantity <= p.MinStockLevel THEN 'Low Stock'
					WHEN p.Quantity = 0 THEN 'Out of Stock'
					WHEN p.Quantity <= p.ReorderPoint THEN 'Reorder Soon'
					ELSE 'In Stock'
				END AS StockStatus,
				p.Created,
				p.Modified
			FROM Products p
			LEFT JOIN Categories c ON p.Category = c.CategoryId
			LEFT JOIN (
				SELECT 
					oi.ProductId,
					COUNT(*) AS Last30Days
				FROM OrderItems oi
				INNER JOIN Orders o ON oi.OrderId = o.OrderId
				WHERE o.CreatedAt >= DATEADD(DAY, -30, GETUTCDATE())
					AND o.Active = 1 AND oi.Active = 1
				GROUP BY oi.ProductId
			) recentSales ON p.ProductId = recentSales.ProductId
			LEFT JOIN (
				SELECT 
					oi.ProductId,
					SUM(oi.Total) AS TotalRevenue
				FROM OrderItems oi
				INNER JOIN Orders o ON oi.OrderId = o.OrderId
				WHERE o.Active = 1 AND oi.Active = 1
				GROUP BY oi.ProductId
			) revenue ON p.ProductId = revenue.ProductId
			LEFT JOIN (
				SELECT 
					ProductId,
					COUNT(*) AS ReviewCount,
					AVG(CAST(Rating AS DECIMAL(3,2))) AS AvgRating
				FROM ProductReviews 
				WHERE Active = 1 AND IsApproved = 1
				GROUP BY ProductId
			) reviews ON p.ProductId = reviews.ProductId
			LEFT JOIN (
				SELECT 
					ProductId,
					COUNT(*) AS InCartCount
				FROM CartItems 
				WHERE Active = 1
				GROUP BY ProductId
			) cart ON p.ProductId = cart.ProductId
			LEFT JOIN (
				SELECT 
					ProductId,
					COUNT(*) AS WishlistCount
				FROM ProductWishList 
				WHERE Active = 1
				GROUP BY ProductId
			) wishlist ON p.ProductId = wishlist.ProductId
			WHERE p.Active = 1;
			
			-- Order Analytics View
			CREATE OR ALTER VIEW [dbo].[VW_ORDER_ANALYTICS]
			AS
			SELECT 
				o.OrderId,
				o.OrderNumber,
				o.UserId,
				u.FullName AS CustomerName,
				u.Email AS CustomerEmail,
				o.TenantId,
				o.OrderStatus,
				o.PaymentStatus,
				o.TotalAmount,
				o.CreatedAt,
				o.UpdatedAt,
				-- Order metrics
				ISNULL(items.ItemCount, 0) AS ItemCount,
				ISNULL(items.TotalQuantity, 0) AS TotalQuantity,
				-- Time metrics
				DATEDIFF(HOUR, o.CreatedAt, ISNULL(o.ShippedAt, GETUTCDATE())) AS HoursToShip,
				DATEDIFF(HOUR, o.ShippedAt, ISNULL(o.DeliveredAt, GETUTCDATE())) AS HoursToDeliver,
				o.OrderAge AS DaysOld,
				-- Status flags
				CASE WHEN o.OrderStatus = 'Delivered' THEN 1 ELSE 0 END AS IsDelivered,
				CASE WHEN o.OrderStatus = 'Cancelled' THEN 1 ELSE 0 END AS IsCancelled,
				CASE WHEN o.PaymentStatus = 'Paid' THEN 1 ELSE 0 END AS IsPaid,
				-- Customer metrics
				customer.TotalOrders,
				customer.TotalSpent,
				customer.AvgOrderValue
			FROM Orders o
			INNER JOIN Users u ON o.UserId = u.UserId
			LEFT JOIN (
				SELECT 
					OrderId,
					COUNT(*) AS ItemCount,
					SUM(Quantity) AS TotalQuantity
				FROM OrderItems 
				WHERE Active = 1
				GROUP BY OrderId
			) items ON o.OrderId = items.OrderId
			LEFT JOIN (
				SELECT 
					UserId,
					COUNT(*) AS TotalOrders,
					SUM(TotalAmount) AS TotalSpent,
					AVG(TotalAmount) AS AvgOrderValue
				FROM Orders 
				WHERE Active = 1
				GROUP BY UserId
			) customer ON o.UserId = customer.UserId
			WHERE o.Active = 1;
			
			-- User Activity Summary View
			CREATE OR ALTER VIEW [dbo].[VW_USER_ACTIVITY_SUMMARY]
			AS
			SELECT 
				u.UserId,
				u.FullName,
				u.Email,
				u.TenantId,
				u.CreatedAt AS RegistrationDate,
				u.LastLogin,
				u.Active,
				u.AccountLocked,
				-- Activity metrics
				ISNULL(activity.LoginCount, 0) AS LoginCount,
				ISNULL(activity.LastActivityDate, u.CreatedAt) AS LastActivityDate,
				ISNULL(orders.OrderCount, 0) AS TotalOrders,
				ISNULL(orders.TotalSpent, 0) AS TotalSpent,
				ISNULL(cart.CartItems, 0) AS CurrentCartItems,
				ISNULL(wishlist.WishlistItems, 0) AS WishlistItems,
				-- Engagement score (0-100)
				CASE 
					WHEN u.Active = 0 THEN 0
					WHEN u.LastLogin IS NULL THEN 10
					WHEN DATEDIFF(DAY, u.LastLogin, GETUTCDATE()) > 90 THEN 20
					WHEN DATEDIFF(DAY, u.LastLogin, GETUTCDATE()) > 30 THEN 40
					WHEN DATEDIFF(DAY, u.LastLogin, GETUTCDATE()) > 7 THEN 60
					WHEN ISNULL(orders.OrderCount, 0) > 5 THEN 100
					WHEN ISNULL(orders.OrderCount, 0) > 0 THEN 80
					ELSE 50
				END AS EngagementScore
			FROM Users u
			LEFT JOIN (
				SELECT 
					UserId,
					COUNT(*) AS LoginCount,
					MAX(CreatedAt) AS LastActivityDate
				FROM UserActivityLog 
				WHERE ActivityType = 'LOGIN'
				GROUP BY UserId
			) activity ON u.UserId = activity.UserId
			LEFT JOIN (
				SELECT 
					UserId,
					COUNT(*) AS OrderCount,
					SUM(TotalAmount) AS TotalSpent
				FROM Orders 
				WHERE Active = 1
				GROUP BY UserId
			) orders ON u.UserId = orders.UserId
			LEFT JOIN (
				SELECT 
					UserId,
					COUNT(*) AS CartItems
				FROM CartItems 
				WHERE Active = 1
				GROUP BY UserId
			) cart ON u.UserId = cart.UserId
			LEFT JOIN (
				SELECT 
					UserId,
					COUNT(*) AS WishlistItems
				FROM ProductWishList 
				WHERE Active = 1
				GROUP BY UserId
			) wishlist ON u.UserId = wishlist.UserId;
		]]>
	</query>
	
	<query Id="CREATE_BUSINESS_INTELLIGENCE_FUNCTIONS">
		<![CDATA[
			-- ====================================== 
			-- BUSINESS INTELLIGENCE FUNCTIONS
			-- Advanced analytics and reporting functions
			-- ====================================== 
			
			-- Function to calculate customer lifetime value
			CREATE OR ALTER FUNCTION [dbo].[FN_CALCULATE_CUSTOMER_LTV](@UserId BIGINT)
			RETURNS DECIMAL(18,2)
			AS
			BEGIN
				DECLARE @LTV DECIMAL(18,2) = 0;
				DECLARE @AvgOrderValue DECIMAL(18,2) = 0;
				DECLARE @OrderFrequency DECIMAL(18,2) = 0;
				DECLARE @CustomerLifespan DECIMAL(18,2) = 0;
				DECLARE @TotalOrders INT = 0;
				DECLARE @FirstOrderDate DATETIME2(7);
				DECLARE @LastOrderDate DATETIME2(7);
				
				-- Get customer order statistics
				SELECT 
					@TotalOrders = COUNT(*),
					@AvgOrderValue = AVG(TotalAmount),
					@FirstOrderDate = MIN(CreatedAt),
					@LastOrderDate = MAX(CreatedAt)
				FROM Orders 
				WHERE UserId = @UserId AND Active = 1;
				
				IF @TotalOrders > 1
				BEGIN
					-- Calculate customer lifespan in years
					SET @CustomerLifespan = DATEDIFF(DAY, @FirstOrderDate, @LastOrderDate) / 365.0;
					IF @CustomerLifespan = 0 SET @CustomerLifespan = 1; -- Minimum 1 year
					
					-- Calculate order frequency (orders per year)
					SET @OrderFrequency = @TotalOrders / @CustomerLifespan;
					
					-- Calculate LTV: Average Order Value × Order Frequency × Customer Lifespan
					SET @LTV = @AvgOrderValue * @OrderFrequency * @CustomerLifespan;
				END
				ELSE IF @TotalOrders = 1
				BEGIN
					-- For single order customers, use average order value
					SET @LTV = @AvgOrderValue;
				END
				
				RETURN ISNULL(@LTV, 0);
			END;
			
			-- Function to get product recommendation score
			CREATE OR ALTER FUNCTION [dbo].[FN_GET_RECOMMENDATION_SCORE](@ProductId BIGINT, @UserId BIGINT)
			RETURNS DECIMAL(5,2)
			AS
			BEGIN
				DECLARE @Score DECIMAL(5,2) = 0;
				DECLARE @CategoryMatch DECIMAL(5,2) = 0;
				DECLARE @PriceMatch DECIMAL(5,2) = 0;
				DECLARE @RatingBonus DECIMAL(5,2) = 0;
				DECLARE @PopularityBonus DECIMAL(5,2) = 0;
				
				-- Category preference score (based on user's order history)
				IF EXISTS (
					SELECT 1 
					FROM Orders o
					INNER JOIN OrderItems oi ON o.OrderId = oi.OrderId
					INNER JOIN Products p1 ON oi.ProductId = p1.ProductId
					INNER JOIN Products p2 ON p2.ProductId = @ProductId
					WHERE o.UserId = @UserId 
						AND p1.Category = p2.Category 
						AND o.Active = 1 AND oi.Active = 1
				)
				BEGIN
					SET @CategoryMatch = 3.0;
				END
				
				-- Price preference score (within user's typical price range)
				DECLARE @AvgUserPrice DECIMAL(18,2);
				SELECT @AvgUserPrice = AVG(oi.Price)
				FROM Orders o
				INNER JOIN OrderItems oi ON o.OrderId = oi.OrderId
				WHERE o.UserId = @UserId AND o.Active = 1 AND oi.Active = 1;
				
				IF @AvgUserPrice IS NOT NULL
				BEGIN
					DECLARE @ProductPrice DECIMAL(18,2);
					SELECT @ProductPrice = Price FROM Products WHERE ProductId = @ProductId;
					
					IF ABS(@ProductPrice - @AvgUserPrice) / @AvgUserPrice <= 0.5 -- Within 50% of average
					BEGIN
						SET @PriceMatch = 2.0;
					END
				END
				
				-- Rating bonus
				DECLARE @ProductRating DECIMAL(3,2);
				SELECT @ProductRating = Rating FROM Products WHERE ProductId = @ProductId;
				SET @RatingBonus = ISNULL(@ProductRating, 0);
				
				-- Popularity bonus
				DECLARE @UserBuyCount INT;
				SELECT @UserBuyCount = UserBuyCount FROM Products WHERE ProductId = @ProductId;
				SET @PopularityBonus = CASE 
					WHEN @UserBuyCount > 100 THEN 2.0
					WHEN @UserBuyCount > 50 THEN 1.5
					WHEN @UserBuyCount > 10 THEN 1.0
					ELSE 0.5
				END;
				
				-- Calculate total score
				SET @Score = @CategoryMatch + @PriceMatch + @RatingBonus + @PopularityBonus;
				
				RETURN @Score;
			END;
		]]>
	</query>
	<query Id="xc_get_app_config_by_key">
		<![CDATA[
            SELECT CONFIGVALUE
            FROM XC_APPCONFIG WITH (NOLOCK)
            WHERE CONFIGKEY=@CONFIG_KEY
		]]>
	</query>
	<query Id="SP_SEARCH_PRODUCTS">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_SEARCH_PRODUCTS]
				@TenantId BIGINT,
				@Page INT = 1,
				@Limit INT = 10,
				@Offset INT = 0,
				@Search NVARCHAR(255) = '',
				@Category INT = NULL,
				@MinPrice DECIMAL(18,2) = NULL,
				@MaxPrice DECIMAL(18,2) = NULL,
				@Rating INT = NULL,
				@InStock BIT = NULL,
				@BestSeller BIT = NULL,
				@HasOffer BIT = NULL,
				@SortBy NVARCHAR(50) = 'created',
				@SortOrder NVARCHAR(10) = 'desc'
			AS
			BEGIN
				SET NOCOUNT ON;
				
				-- Declare variables
				DECLARE @SQL NVARCHAR(MAX);
				DECLARE @WhereClause NVARCHAR(MAX) = '';
				DECLARE @OrderByClause NVARCHAR(MAX) = '';
				DECLARE @TotalCount INT = 0;
				
				-- Build WHERE clause dynamically
				SET @WhereClause = 'WHERE p.TenantId = ' + CAST(@TenantId AS NVARCHAR) + ' ';
				
				-- Search filter
				IF @Search IS NOT NULL AND @Search != ''
				BEGIN
					SET @WhereClause = @WhereClause + 
						'AND (p.ProductName LIKE ''%' + @Search + '%'' 
						 OR p.ProductDescription LIKE ''%' + @Search + '%'' 
						 OR p.ProductCode LIKE ''%' + @Search + '%'') ';
				END
				
				-- Category filter
				IF @Category IS NOT NULL
				BEGIN
					SET @WhereClause = @WhereClause + 'AND p.Category = ' + CAST(@Category AS NVARCHAR) + ' ';
				END
				
				-- Price range filter
				IF @MinPrice IS NOT NULL
				BEGIN
					SET @WhereClause = @WhereClause + 'AND p.Price >= ' + CAST(@MinPrice AS NVARCHAR) + ' ';
				END
				
				IF @MaxPrice IS NOT NULL
				BEGIN
					SET @WhereClause = @WhereClause + 'AND p.Price <= ' + CAST(@MaxPrice AS NVARCHAR) + ' ';
				END
				
				-- Rating filter
				IF @Rating IS NOT NULL
				BEGIN
					SET @WhereClause = @WhereClause + 'AND p.Rating >= ' + CAST(@Rating AS NVARCHAR) + ' ';
				END
				
				-- Stock filter
				IF @InStock IS NOT NULL
				BEGIN
					IF @InStock = 1
						SET @WhereClause = @WhereClause + 'AND p.Quantity > 0 ';
					ELSE
						SET @WhereClause = @WhereClause + 'AND p.Quantity = 0 ';
				END
				
				-- Best seller filter
				IF @BestSeller IS NOT NULL AND @BestSeller = 1
				BEGIN
					SET @WhereClause = @WhereClause + 'AND p.BestSeller = 1 ';
				END
				
				-- Has offer filter
				IF @HasOffer IS NOT NULL AND @HasOffer = 1
				BEGIN
					SET @WhereClause = @WhereClause + 'AND (p.Offer IS NOT NULL AND p.Offer != '''') ';
				END
				
				-- Active products only
				SET @WhereClause = @WhereClause + 'AND p.Active = 1 ';
				
				-- Build ORDER BY clause
				SET @OrderByClause = 'ORDER BY ';
				
				IF @SortBy = 'productName'
					SET @OrderByClause = @OrderByClause + 'p.ProductName ';
				ELSE IF @SortBy = 'price'
					SET @OrderByClause = @OrderByClause + 'p.Price ';
				ELSE IF @SortBy = 'rating'
					SET @OrderByClause = @OrderByClause + 'p.Rating ';
				ELSE IF @SortBy = 'userBuyCount'
					SET @OrderByClause = @OrderByClause + 'p.UserBuyCount ';
				ELSE
					SET @OrderByClause = @OrderByClause + 'p.Created ';
				
				IF @SortOrder = 'asc'
					SET @OrderByClause = @OrderByClause + 'ASC ';
				ELSE
					SET @OrderByClause = @OrderByClause + 'DESC ';
				
				-- Get total count first
				SET @SQL = '
				SELECT COUNT(*) as TotalCount
				FROM Products p 
				' + @WhereClause;
				
				-- Create temp table for count
				CREATE TABLE #TempCount (TotalCount INT);
				INSERT INTO #TempCount
				EXEC sp_executesql @SQL;
				
				SELECT @TotalCount = TotalCount FROM #TempCount;
				DROP TABLE #TempCount;
				
				-- Get paginated results
				SET @SQL = '
				SELECT 
					p.ProductId,
					p.TenantId,
					p.ProductName,
					p.ProductDescription,
					p.ProductCode,
					p.FullDescription,
					p.Specification,
					p.Story,
					p.PackQuantity,
					p.Quantity,
					p.Total,
					p.Price,
					p.Category,
					p.Rating,
					p.Active,
					p.Trending,
					p.UserBuyCount,
					p.Return,
					p.Created,
					p.Modified,
					CASE WHEN p.Quantity > 0 THEN 1 ELSE 0 END as InStock,
					p.BestSeller,
					p.DeliveryDate,
					p.Offer,
					p.OrderBy,
					p.UserId,
					p.Overview,
					p.LongDescription
				FROM Products p 
				' + @WhereClause + @OrderByClause + '
				OFFSET ' + CAST(@Offset AS NVARCHAR) + ' ROWS
				FETCH NEXT ' + CAST(@Limit AS NVARCHAR) + ' ROWS ONLY';
				
				-- Execute main query
				EXEC sp_executesql @SQL;
				
				-- Return total count as second result set
				SELECT @TotalCount as TotalCount;
				
			END
		]]>
	</query>
	<query Id="SP_GET_PRODUCT_BY_ID">
		<![CDATA[
			SELECT 
				p.ProductId,
				p.TenantId,
				p.ProductName,
				p.ProductDescription,
				p.ProductCode,
				p.FullDescription,
				p.Specification,
				p.Story,
				p.PackQuantity,
				p.Quantity,
				p.Total,
				p.Price,
				p.Category,
				p.Rating,
				p.Active,
				p.Trending,
				p.UserBuyCount,
				p.Return,
				p.Created,
				p.Modified,
				CASE WHEN p.Quantity > 0 THEN 1 ELSE 0 END as InStock,
				p.BestSeller,
				p.DeliveryDate,
				p.Offer,
				p.OrderBy,
				p.UserId,
				p.Overview,
				p.LongDescription
			FROM Products p WITH (NOLOCK)
			WHERE p.ProductId = @ProductId
				AND p.Active = 1;

			-- Get product images
			SELECT 
				i.ImageId,
				i.ImageUrl as Poster,
				i.IsMain as [Main],
				i.Active,
				i.OrderBy
			FROM ProductImages i WITH (NOLOCK)
			WHERE i.ProductId = @ProductId
				AND i.Active = 1
			ORDER BY i.OrderBy;
		]]>
	</query>
		<query Id="SP_ADD_PRODUCT">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADD_PRODUCT]
				@TenantId BIGINT,
				@ProductName NVARCHAR(255),
				@ProductDescription NVARCHAR(500),
				@ProductCode NVARCHAR(100),
				@FullDescription NVARCHAR(MAX),
				@Specification NVARCHAR(MAX),
				@Story NVARCHAR(MAX),
				@PackQuantity INT,
				@Quantity INT,
				@Total INT,
				@Price DECIMAL(18,2),
				@Category INT,
				@Rating INT,
				@Active BIT,
				@Trending INT,
				@UserBuyCount INT,
				@Return INT,
				@BestSeller BIT,
				@DeliveryDate INT,
				@Offer NVARCHAR(100),
				@OrderBy INT,
				@UserId BIGINT,
				@CreatedBy BIGINT
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Check if product code already exists for this tenant
					IF EXISTS (SELECT 1 FROM Products WHERE TenantId = @TenantId AND ProductCode = @ProductCode)
					BEGIN
						RAISERROR('Product code already exists for this tenant.', 16, 1);
						RETURN;
					END
					
					-- Insert new product
					INSERT INTO Products (
						TenantId,
						ProductName,
						ProductDescription,
						ProductCode,
						FullDescription,
						Specification,
						Story,
						PackQuantity,
						Quantity,
						Total,
						Price,
						Category,
						Rating,
						Active,
						Trending,
						UserBuyCount,
						[Return],
						BestSeller,
						DeliveryDate,
						Offer,
						OrderBy,
						UserId,
						Created,
						Modified,
						CreatedBy,
						ModifiedBy
					)
					VALUES (
						@TenantId,
						@ProductName,
						@ProductDescription,
						@ProductCode,
						@FullDescription,
						@Specification,
						@Story,
						@PackQuantity,
						@Quantity,
						@Total,
						@Price,
						@Category,
						@Rating,
						@Active,
						@Trending,
						@UserBuyCount,
						@Return,
						@BestSeller,
						@DeliveryDate,
						@Offer,
						@OrderBy,
						@UserId,
						GETUTCDATE(),
						GETUTCDATE(),
						@CreatedBy,
						@CreatedBy
					);
					
					-- Get the new product ID
					DECLARE @ProductId BIGINT = SCOPE_IDENTITY();
					
					-- Return the new product ID
					SELECT @ProductId AS ProductId;
					
					COMMIT TRANSACTION;
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_UPDATE_PRODUCT">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_UPDATE_PRODUCT]
				@ProductId BIGINT,
				@TenantId BIGINT,
				@ProductName NVARCHAR(255),
				@ProductDescription NVARCHAR(500),
				@ProductCode NVARCHAR(100),
				@FullDescription NVARCHAR(MAX),
				@Specification NVARCHAR(MAX),
				@Story NVARCHAR(MAX),
				@PackQuantity INT,
				@Quantity INT,
				@Total INT,
				@Price DECIMAL(18,2),
				@Category INT,
				@Rating INT,
				@Active BIT,
				@Trending INT,
				@UserBuyCount INT,
				@Return INT,
				@BestSeller BIT,
				@DeliveryDate INT,
				@Offer NVARCHAR(100),
				@OrderBy INT,
				@UserId BIGINT,
				@ModifiedBy BIGINT
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Check if product exists and belongs to the tenant
					IF NOT EXISTS (SELECT 1 FROM Products WHERE ProductId = @ProductId AND TenantId = @TenantId)
					BEGIN
						RAISERROR('Product not found or does not belong to this tenant.', 16, 1);
						RETURN;
					END
					
					-- Check if product code already exists for another product of this tenant
					IF EXISTS (
						SELECT 1 
						FROM Products 
						WHERE TenantId = @TenantId 
							AND ProductCode = @ProductCode 
							AND ProductId != @ProductId
					)
					BEGIN
						RAISERROR('Product code already exists for another product.', 16, 1);
						RETURN;
					END
					
					-- Update product
					UPDATE Products
					SET
						ProductName = @ProductName,
						ProductDescription = @ProductDescription,
						ProductCode = @ProductCode,
						FullDescription = @FullDescription,
						Specification = @Specification,
						Story = @Story,
						PackQuantity = @PackQuantity,
						Quantity = @Quantity,
						Total = @Total,
						Price = @Price,
						Category = @Category,
						Rating = @Rating,
						Active = @Active,
						Trending = @Trending,
						UserBuyCount = @UserBuyCount,
						[Return] = @Return,
						BestSeller = @BestSeller,
						DeliveryDate = @DeliveryDate,
						Offer = @Offer,
						OrderBy = @OrderBy,
						UserId = @UserId,
						Modified = GETUTCDATE(),
						ModifiedBy = @ModifiedBy
					WHERE ProductId = @ProductId
						AND TenantId = @TenantId;
					
					-- Return success
					SELECT @ProductId AS ProductId;
					
					COMMIT TRANSACTION;
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_DELETE_PRODUCT">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_DELETE_PRODUCT]
				@ProductId BIGINT,
				@TenantId BIGINT,
				@UserId BIGINT
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Check if product exists and belongs to the tenant
					IF NOT EXISTS (SELECT 1 FROM Products WHERE ProductId = @ProductId AND TenantId = @TenantId)
					BEGIN
						RAISERROR('Product not found or does not belong to this tenant.', 16, 1);
						RETURN;
					END
					
					-- Check if product is referenced in any orders or carts
					IF EXISTS (
						SELECT 1 
						FROM CartItems 
						WHERE ProductId = @ProductId AND Active = 1
						   OR EXISTS (SELECT 1 FROM OrderItems WHERE ProductId = @ProductId AND Active = 1)
					)
					BEGIN
						-- Soft delete - just mark as inactive
						UPDATE Products
						SET 
							Active = 0,
							Modified = GETUTCDATE(),
							ModifiedBy = @UserId
						WHERE ProductId = @ProductId
							AND TenantId = @TenantId;
					END
					ELSE
					BEGIN
						-- Hard delete - first delete related records
						DELETE FROM ProductImages WHERE ProductId = @ProductId;
						DELETE FROM ProductReviews WHERE ProductId = @ProductId;
						DELETE FROM ProductWishList WHERE ProductId = @ProductId;
						
						-- Then delete the product
						DELETE FROM Products 
						WHERE ProductId = @ProductId 
							AND TenantId = @TenantId;
					END
					
					-- Return success
					SELECT @ProductId AS ProductId;
					
					COMMIT TRANSACTION;
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_ALL_CATEGORIES">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_ALL_CATEGORIES]
				@TenantId BIGINT = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Get all categories with optional tenant filtering
					SELECT 
						c.CategoryId,
						c.CategoryName AS Category,
						c.Active,
						c.HasSubMenu AS SubMenu,
						c.Created,
						c.Modified,
						c.OrderBy,
						c.Description,
						c.Icon,
						c.ParentCategoryId,
						c.TenantId
					FROM Categories c
					WHERE (@TenantId IS NULL OR c.TenantId = @TenantId)
						AND c.Active = 1
					ORDER BY c.OrderBy, c.CategoryName;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADD_CATEGORY">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADD_CATEGORY]
				@TenantId BIGINT,
				@CategoryName NVARCHAR(255),
				@Description NVARCHAR(MAX) = NULL,
				@Active BIT = 1,
				@ParentCategoryId BIGINT = NULL,
				@OrderBy INT = 0,
				@Icon NVARCHAR(255) = NULL,
				@HasSubMenu BIT = 0,
				@Link NVARCHAR(500) = NULL,
				@UserId BIGINT
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Check if category name already exists for this tenant
					IF EXISTS (SELECT 1 FROM Categories WHERE CategoryName = @CategoryName AND TenantId = @TenantId)
					BEGIN
						RAISERROR('Category name already exists for this tenant.', 16, 1);
						RETURN;
					END
					
					-- Validate parent category if provided
					IF @ParentCategoryId IS NOT NULL
					BEGIN
						IF NOT EXISTS (SELECT 1 FROM Categories WHERE CategoryId = @ParentCategoryId AND TenantId = @TenantId)
						BEGIN
							RAISERROR('Parent category does not exist.', 16, 1);
							RETURN;
						END
					END
					
					-- Insert new category
					INSERT INTO Categories (
						TenantId,
						CategoryName,
						Description,
						Active,
						ParentCategoryId,
						OrderBy,
						Icon,
						HasSubMenu,
						Link,
						Created,
						CreatedBy,
						Modified,
						ModifiedBy
					) VALUES (
						@TenantId,
						@CategoryName,
						@Description,
						@Active,
						@ParentCategoryId,
						@OrderBy,
						@Icon,
						@HasSubMenu,
						@Link,
						GETUTCDATE(),
						@UserId,
						GETUTCDATE(),
						@UserId
					);
					
					-- Return the new category ID
					SELECT SCOPE_IDENTITY() AS CategoryId;
					
					COMMIT TRANSACTION;
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_UPDATE_CATEGORY">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_UPDATE_CATEGORY]
				@CategoryId BIGINT,
				@TenantId BIGINT,
				@CategoryName NVARCHAR(255),
				@Description NVARCHAR(MAX) = NULL,
				@Active BIT = 1,
				@ParentCategoryId BIGINT = NULL,
				@OrderBy INT = 0,
				@Icon NVARCHAR(255) = NULL,
				@HasSubMenu BIT = 0,
				@Link NVARCHAR(500) = NULL,
				@UserId BIGINT
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Check if category exists and belongs to the tenant
					IF NOT EXISTS (SELECT 1 FROM Categories WHERE CategoryId = @CategoryId AND TenantId = @TenantId)
					BEGIN
						RAISERROR('Category not found or does not belong to this tenant.', 16, 1);
						RETURN;
					END
					
					-- Check if new category name already exists for this tenant (excluding current category)
					IF EXISTS (SELECT 1 FROM Categories WHERE CategoryName = @CategoryName AND TenantId = @TenantId AND CategoryId != @CategoryId)
					BEGIN
						RAISERROR('Category name already exists for this tenant.', 16, 1);
						RETURN;
					END
					
					-- Validate parent category if provided
					IF @ParentCategoryId IS NOT NULL
					BEGIN
						IF NOT EXISTS (SELECT 1 FROM Categories WHERE CategoryId = @ParentCategoryId AND TenantId = @TenantId)
						BEGIN
							RAISERROR('Parent category does not exist.', 16, 1);
							RETURN;
						END
						
						-- Prevent circular reference (category cannot be its own parent or grandparent)
						IF @ParentCategoryId = @CategoryId
						BEGIN
							RAISERROR('Category cannot be its own parent.', 16, 1);
							RETURN;
						END
					END
					
					-- Update category
					UPDATE Categories
					SET 
						CategoryName = @CategoryName,
						Description = @Description,
						Active = @Active,
						ParentCategoryId = @ParentCategoryId,
						OrderBy = @OrderBy,
						Icon = @Icon,
						HasSubMenu = @HasSubMenu,
						Link = @Link,
						Modified = GETUTCDATE(),
						ModifiedBy = @UserId
					WHERE CategoryId = @CategoryId
						AND TenantId = @TenantId;
					
					-- Return the updated category ID
					SELECT @CategoryId AS CategoryId;
					
					COMMIT TRANSACTION;
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_MENU_MASTER">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_MENU_MASTER]
				@TenantId BIGINT = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Get menu master with categories
					SELECT 
						m.MenuId,
						m.MenuName,
						m.OrderBy,
						m.Active,
						m.Image,
						m.SubMenu,
						m.TenantId,
						m.Created,
						m.Modified,
						-- Category information
						c.CategoryId,
						c.CategoryName AS Category,
						c.Active AS CategoryActive,
						c.OrderBy AS CategoryOrderBy,
						c.Icon AS CategoryIcon,
						c.Description AS CategoryDescription
					FROM MenuMaster m
					LEFT JOIN Categories c ON m.MenuId = c.MenuId 
						AND c.Active = 1
						AND (@TenantId IS NULL OR c.TenantId = @TenantId)
					WHERE m.Active = 1
						AND (@TenantId IS NULL OR m.TenantId = @TenantId)
					ORDER BY m.OrderBy, m.MenuName, c.OrderBy, c.CategoryName;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_USER_LOGIN">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_USER_LOGIN]
				@EmailOrPhone NVARCHAR(255),
				@Password NVARCHAR(255),
				@RememberMe BIT = 0
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					DECLARE @UserId BIGINT = NULL;
					DECLARE @IsActive BIT = 0;
					DECLARE @PasswordHash NVARCHAR(255);
					DECLARE @Salt NVARCHAR(255);
					DECLARE @LoginAttempts INT = 0;
					DECLARE @AccountLocked BIT = 0;
					DECLARE @LastLoginAttempt DATETIME;
					
					-- Find user by email or phone
					SELECT 
						@UserId = UserId,
						@IsActive = Active,
						@PasswordHash = PasswordHash,
						@Salt = Salt,
						@LoginAttempts = LoginAttempts,
						@AccountLocked = AccountLocked,
						@LastLoginAttempt = LastLoginAttempt
					FROM Users 
					WHERE (Email = @EmailOrPhone OR Phone = @EmailOrPhone)
						AND Active = 1;
					
					-- Check if user exists
					IF @UserId IS NULL
					BEGIN
						RAISERROR('Invalid email/phone or password.', 16, 1);
						RETURN;
					END
					
					-- Check if account is locked
					IF @AccountLocked = 1
					BEGIN
						-- Check if lock period has expired (30 minutes)
						IF DATEDIFF(MINUTE, @LastLoginAttempt, GETUTCDATE()) < 30
						BEGIN
							RAISERROR('Account is temporarily locked due to multiple failed login attempts. Please try again later.', 16, 1);
							RETURN;
						END
						ELSE
						BEGIN
							-- Unlock account
							UPDATE Users 
							SET AccountLocked = 0, LoginAttempts = 0 
							WHERE UserId = @UserId;
							SET @AccountLocked = 0;
							SET @LoginAttempts = 0;
						END
					END
					
					-- Verify password (In real implementation, you would hash the input password with salt)
					-- For demo purposes, we'll do a simple comparison
					IF @PasswordHash != HASHBYTES('SHA256', @Password + @Salt)
					BEGIN
						-- Increment login attempts
						SET @LoginAttempts = @LoginAttempts + 1;
						
						-- Lock account after 5 failed attempts
						IF @LoginAttempts >= 5
						BEGIN
							UPDATE Users 
							SET LoginAttempts = @LoginAttempts, 
								AccountLocked = 1, 
								LastLoginAttempt = GETUTCDATE()
							WHERE UserId = @UserId;
							
							RAISERROR('Account has been locked due to multiple failed login attempts.', 16, 1);
							RETURN;
						END
						ELSE
						BEGIN
							UPDATE Users 
							SET LoginAttempts = @LoginAttempts, 
								LastLoginAttempt = GETUTCDATE()
							WHERE UserId = @UserId;
							
							RAISERROR('Invalid email/phone or password.', 16, 1);
							RETURN;
						END
					END
					
					-- Successful login - reset attempts and update last login
					UPDATE Users 
					SET LoginAttempts = 0, 
						LastLogin = GETUTCDATE(),
						LastLoginAttempt = GETUTCDATE(),
						AccountLocked = 0
					WHERE UserId = @UserId;
					
					-- Return user information
					SELECT 
						u.UserId,
						u.FirstName,
						u.LastName,
						u.Email,
						u.Phone,
						u.Active,
						u.TenantId,
						u.LastLogin,
						ur.RoleId,
						r.RoleName,
						r.RoleDescription,
						@RememberMe AS RememberMe
					FROM Users u
					LEFT JOIN UserRoles ur ON u.UserId = ur.UserId
					LEFT JOIN Roles r ON ur.RoleId = r.RoleId
					WHERE u.UserId = @UserId
						AND u.Active = 1;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_USER_REGISTER">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_USER_REGISTER]
				@Name NVARCHAR(255),
				@Email NVARCHAR(255),
				@Phone NVARCHAR(50),
				@Password NVARCHAR(255),
				@TenantId BIGINT = 1,
				@AgreeToTerms BIT = 1
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @UserId BIGINT;
					DECLARE @Salt NVARCHAR(255);
					DECLARE @PasswordHash NVARCHAR(255);
					DECLARE @DefaultRoleId BIGINT = 2; -- Assuming 2 is the default user role
					
					-- Check if email already exists
					IF EXISTS (SELECT 1 FROM Users WHERE Email = @Email)
					BEGIN
						RAISERROR('Email address is already registered.', 16, 1);
						RETURN;
					END
					
					-- Check if phone already exists
					IF EXISTS (SELECT 1 FROM Users WHERE Phone = @Phone)
					BEGIN
						RAISERROR('Phone number is already registered.', 16, 1);
						RETURN;
					END
					
					-- Validate terms agreement
					IF @AgreeToTerms = 0
					BEGIN
						RAISERROR('You must agree to the terms and conditions.', 16, 1);
						RETURN;
					END
					
					-- Generate salt and hash password
					SET @Salt = CONVERT(NVARCHAR(255), NEWID());
					SET @PasswordHash = CONVERT(NVARCHAR(255), HASHBYTES('SHA256', @Password + @Salt), 2);
					
					-- Parse name into first and last name
					DECLARE @FirstName NVARCHAR(255);
					DECLARE @LastName NVARCHAR(255);
					DECLARE @SpaceIndex INT = CHARINDEX(' ', @Name);
					
					IF @SpaceIndex > 0
					BEGIN
						SET @FirstName = LEFT(@Name, @SpaceIndex - 1);
						SET @LastName = RIGHT(@Name, LEN(@Name) - @SpaceIndex);
					END
					ELSE
					BEGIN
						SET @FirstName = @Name;
						SET @LastName = '';
					END
					
					-- Insert new user
					INSERT INTO Users (
						FirstName,
						LastName,
						Email,
						Phone,
						PasswordHash,
						Salt,
						TenantId,
						Active,
						EmailVerified,
						PhoneVerified,
						LoginAttempts,
						AccountLocked,
						CreatedAt,
						UpdatedAt,
						AgreeToTerms
					) VALUES (
						@FirstName,
						@LastName,
						@Email,
						@Phone,
						@PasswordHash,
						@Salt,
						@TenantId,
						1, -- Active
						0, -- EmailVerified
						0, -- PhoneVerified
						0, -- LoginAttempts
						0, -- AccountLocked
						GETUTCDATE(),
						GETUTCDATE(),
						@AgreeToTerms
					);
					
					-- Get the new user ID
					SET @UserId = SCOPE_IDENTITY();
					
					-- Assign default role to user
					INSERT INTO UserRoles (UserId, RoleId, CreatedAt)
					VALUES (@UserId, @DefaultRoleId, GETUTCDATE());
					
					-- Return user information with role
					SELECT 
						u.UserId,
						u.FirstName,
						u.LastName,
						u.Email,
						u.Phone,
						u.Active,
						u.TenantId,
						u.EmailVerified,
						u.PhoneVerified,
						u.CreatedAt,
						ur.RoleId,
						r.RoleName,
						r.RoleDescription
					FROM Users u
					LEFT JOIN UserRoles ur ON u.UserId = ur.UserId
					LEFT JOIN Roles r ON ur.RoleId = r.RoleId
					WHERE u.UserId = @UserId;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_USER_LOGOUT">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_USER_LOGOUT]
				@UserId BIGINT,
				@Token NVARCHAR(MAX) = NULL,
				@RefreshToken NVARCHAR(MAX) = NULL,
				@DeviceId NVARCHAR(255) = NULL,
				@LogoutFromAllDevices BIT = 0
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- If logout from all devices is requested
					IF @LogoutFromAllDevices = 1
					BEGIN
						-- Invalidate all tokens for this user
						UPDATE UserTokens 
						SET IsRevoked = 1, 
							RevokedAt = GETUTCDATE(),
							RevokedReason = 'Logout from all devices'
						WHERE UserId = @UserId 
							AND IsRevoked = 0;
						
						-- Clear remember me sessions
						UPDATE Users 
						SET RememberMeToken = NULL,
							RememberMeExpiry = NULL,
							LastLogout = GETUTCDATE()
						WHERE UserId = @UserId;
					END
					ELSE
					BEGIN
						-- Logout from specific device/token
						IF @Token IS NOT NULL
						BEGIN
							-- Invalidate specific token
							UPDATE UserTokens 
							SET IsRevoked = 1, 
								RevokedAt = GETUTCDATE(),
								RevokedReason = 'User logout'
							WHERE UserId = @UserId 
								AND (Token = @Token OR RefreshToken = @RefreshToken)
								AND IsRevoked = 0;
						END
						
						IF @DeviceId IS NOT NULL
						BEGIN
							-- Invalidate tokens for specific device
							UPDATE UserTokens 
							SET IsRevoked = 1, 
								RevokedAt = GETUTCDATE(),
								RevokedReason = 'Device logout'
							WHERE UserId = @UserId 
								AND DeviceId = @DeviceId
								AND IsRevoked = 0;
						END
						
						-- Update last logout time
						UPDATE Users 
						SET LastLogout = GETUTCDATE()
						WHERE UserId = @UserId;
					END
					
					-- Log the logout activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IPAddress,
						UserAgent,
						DeviceId,
						CreatedAt
					) VALUES (
						@UserId,
						'LOGOUT',
						CASE 
							WHEN @LogoutFromAllDevices = 1 THEN 'Logout from all devices'
							WHEN @DeviceId IS NOT NULL THEN 'Logout from device: ' + @DeviceId
							ELSE 'User logout'
						END,
						NULL, -- IP Address would be passed from application
						NULL, -- User Agent would be passed from application
						@DeviceId,
						GETUTCDATE()
					);
					
					-- Return success status
					SELECT 
						@UserId AS UserId,
						'Logged out successfully' AS Message,
						GETUTCDATE() AS LogoutTime,
						@LogoutFromAllDevices AS LogoutFromAllDevices;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_USER_PROFILE">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_USER_PROFILE]
				@UserId BIGINT,
				@TenantId BIGINT = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Additional tenant validation if provided
					IF @TenantId IS NOT NULL
					BEGIN
						IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND TenantId = @TenantId AND Active = 1)
						BEGIN
							RAISERROR('User not found in the specified tenant.', 16, 1);
							RETURN;
						END
					END
					
					-- Get user profile information
					SELECT 
						u.UserId,
						u.FirstName,
						u.LastName,
						u.Email,
						u.Phone,
						u.Active,
						u.TenantId,
						u.EmailVerified,
						u.PhoneVerified,
						u.CreatedAt,
						u.UpdatedAt,
						u.LastLogin,
						u.LastLogout,
						u.ProfilePicture,
						u.DateOfBirth,
						u.Gender,
						u.Timezone,
						u.Language,
						u.Country,
						u.City,
						u.State,
						u.PostalCode,
						u.Bio,
						u.Website,
						u.CompanyName,
						u.JobTitle,
						u.PreferredContactMethod,
						u.NotificationSettings,
						u.PrivacySettings,
						-- User roles
						ur.RoleId,
						r.RoleName,
						r.RoleDescription,
						-- User addresses
						addr.AddressId,
						addr.AddressType,
						addr.Street,
						addr.City AS AddressCity,
						addr.State AS AddressState,
						addr.PostalCode AS AddressPostalCode,
						addr.Country AS AddressCountry,
						addr.IsDefault AS IsDefaultAddress,
						-- User preferences
						up.PreferenceKey,
						up.PreferenceValue,
						up.PreferenceType
					FROM Users u
					LEFT JOIN UserRoles ur ON u.UserId = ur.UserId
					LEFT JOIN Roles r ON ur.RoleId = r.RoleId
					LEFT JOIN UserAddresses addr ON u.UserId = addr.UserId AND addr.Active = 1
					LEFT JOIN UserPreferences up ON u.UserId = up.UserId AND up.Active = 1
					WHERE u.UserId = @UserId 
						AND u.Active = 1
						AND (@TenantId IS NULL OR u.TenantId = @TenantId)
					ORDER BY ur.RoleId, addr.IsDefault DESC, up.PreferenceKey;
					
					-- Get user statistics (optional)
					SELECT 
						'LOGIN_COUNT' AS StatType,
						COUNT(*) AS StatValue
					FROM UserActivityLog 
					WHERE UserId = @UserId 
						AND ActivityType = 'LOGIN'
						AND CreatedAt >= DATEADD(MONTH, -12, GETUTCDATE())
					
					UNION ALL
					
					SELECT 
						'LAST_ACTIVITY' AS StatType,
						DATEDIFF(DAY, MAX(CreatedAt), GETUTCDATE()) AS StatValue
					FROM UserActivityLog 
					WHERE UserId = @UserId
					
					UNION ALL
					
					SELECT 
						'PROFILE_COMPLETION' AS StatType,
						CASE 
							WHEN ProfilePicture IS NOT NULL THEN 10 ELSE 0 END +
							CASE 
							WHEN DateOfBirth IS NOT NULL THEN 10 ELSE 0 END +
							CASE 
							WHEN Bio IS NOT NULL THEN 10 ELSE 0 END +
							CASE 
							WHEN Phone IS NOT NULL THEN 10 ELSE 0 END +
							CASE 
							WHEN EmailVerified = 1 THEN 20 ELSE 0 END +
							CASE 
							WHEN PhoneVerified = 1 THEN 20 ELSE 0 END +
							20 AS StatValue -- Base score for having name and email
					FROM Users 
					WHERE UserId = @UserId;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_UPDATE_USER_PROFILE">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_UPDATE_USER_PROFILE]
				@UserId BIGINT,
				@Name NVARCHAR(255) = NULL,
				@Phone NVARCHAR(50) = NULL,
				@DateOfBirth DATETIME = NULL,
				@Gender NVARCHAR(20) = NULL,
				@Bio NVARCHAR(MAX) = NULL,
				@Website NVARCHAR(255) = NULL,
				@CompanyName NVARCHAR(255) = NULL,
				@JobTitle NVARCHAR(255) = NULL,
				@Country NVARCHAR(100) = NULL,
				@City NVARCHAR(100) = NULL,
				@State NVARCHAR(100) = NULL,
				@PostalCode NVARCHAR(20) = NULL,
				@Timezone NVARCHAR(100) = NULL,
				@Language NVARCHAR(10) = NULL,
				@PreferredContactMethod NVARCHAR(50) = NULL,
				-- Address Information
				@AddressStreet NVARCHAR(255) = NULL,
				@AddressCity NVARCHAR(100) = NULL,
				@AddressState NVARCHAR(100) = NULL,
				@AddressZipCode NVARCHAR(20) = NULL,
				@AddressCountry NVARCHAR(100) = NULL,
				@AddressType NVARCHAR(50) = 'Home',
				@UpdateAddressIfExists BIT = 1
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Parse name into first and last name if provided
					DECLARE @FirstName NVARCHAR(255) = NULL;
					DECLARE @LastName NVARCHAR(255) = NULL;
					
					IF @Name IS NOT NULL
					BEGIN
						DECLARE @SpaceIndex INT = CHARINDEX(' ', @Name);
						IF @SpaceIndex > 0
						BEGIN
							SET @FirstName = LEFT(@Name, @SpaceIndex - 1);
							SET @LastName = RIGHT(@Name, LEN(@Name) - @SpaceIndex);
						END
						ELSE
						BEGIN
							SET @FirstName = @Name;
							SET @LastName = '';
						END
					END
					
					-- Check if phone number already exists for another user
					IF @Phone IS NOT NULL AND EXISTS (SELECT 1 FROM Users WHERE Phone = @Phone AND UserId != @UserId)
					BEGIN
						RAISERROR('Phone number is already registered to another user.', 16, 1);
						RETURN;
					END
					
					-- Update user profile
					UPDATE Users
					SET 
						FirstName = ISNULL(@FirstName, FirstName),
						LastName = ISNULL(@LastName, LastName),
						Phone = ISNULL(@Phone, Phone),
						DateOfBirth = ISNULL(@DateOfBirth, DateOfBirth),
						Gender = ISNULL(@Gender, Gender),
						Bio = ISNULL(@Bio, Bio),
						Website = ISNULL(@Website, Website),
						CompanyName = ISNULL(@CompanyName, CompanyName),
						JobTitle = ISNULL(@JobTitle, JobTitle),
						Country = ISNULL(@Country, Country),
						City = ISNULL(@City, City),
						State = ISNULL(@State, State),
						PostalCode = ISNULL(@PostalCode, PostalCode),
						Timezone = ISNULL(@Timezone, Timezone),
						Language = ISNULL(@Language, Language),
						PreferredContactMethod = ISNULL(@PreferredContactMethod, PreferredContactMethod),
						UpdatedAt = GETUTCDATE()
					WHERE UserId = @UserId;
					
					-- Handle address update/creation if address information is provided
					IF @AddressStreet IS NOT NULL OR @AddressCity IS NOT NULL OR @AddressState IS NOT NULL 
						OR @AddressZipCode IS NOT NULL OR @AddressCountry IS NOT NULL
					BEGIN
						DECLARE @ExistingAddressId BIGINT = NULL;
						
						-- Check if user has an existing address of the specified type
						SELECT @ExistingAddressId = AddressId 
						FROM UserAddresses 
						WHERE UserId = @UserId 
							AND AddressType = @AddressType 
							AND Active = 1;
						
						IF @ExistingAddressId IS NOT NULL AND @UpdateAddressIfExists = 1
						BEGIN
							-- Update existing address
							UPDATE UserAddresses
							SET 
								Street = ISNULL(@AddressStreet, Street),
								City = ISNULL(@AddressCity, City),
								State = ISNULL(@AddressState, State),
								PostalCode = ISNULL(@AddressZipCode, PostalCode),
								Country = ISNULL(@AddressCountry, Country),
								UpdatedAt = GETUTCDATE()
							WHERE AddressId = @ExistingAddressId;
						END
						ELSE IF @ExistingAddressId IS NULL
						BEGIN
							-- Create new address
							INSERT INTO UserAddresses (
								UserId,
								AddressType,
								Street,
								City,
								State,
								PostalCode,
								Country,
								IsDefault,
								Active,
								CreatedAt,
								UpdatedAt
							) VALUES (
								@UserId,
								@AddressType,
								@AddressStreet,
								@AddressCity,
								@AddressState,
								@AddressZipCode,
								@AddressCountry,
								1, -- Set as default if it's the first address
								1,
								GETUTCDATE(),
								GETUTCDATE()
							);
						END
					END
					
					-- Log the profile update activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						CreatedAt
					) VALUES (
						@UserId,
						'PROFILE_UPDATE',
						'User profile updated',
						GETUTCDATE()
					);
					
					-- Return success status
					SELECT 
						@UserId AS UserId,
						'Profile updated successfully' AS Message,
						GETUTCDATE() AS UpdatedAt;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_RESET_PASSWORD">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_RESET_PASSWORD]
				@ResetToken NVARCHAR(255),
				@NewPassword NVARCHAR(255),
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @UserId BIGINT = NULL;
					DECLARE @TokenExpiry DATETIME = NULL;
					DECLARE @TokenUsed BIT = 0;
					DECLARE @Email NVARCHAR(255) = NULL;
					DECLARE @Salt NVARCHAR(50) = NULL;
					DECLARE @HashedPassword NVARCHAR(255) = NULL;
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					
					-- Validate reset token and get user information
					SELECT 
						@UserId = prt.UserId,
						@TokenExpiry = prt.ExpiresAt,
						@TokenUsed = prt.IsUsed,
						@Email = u.Email
					FROM PasswordResetTokens prt
					INNER JOIN Users u ON prt.UserId = u.UserId
					WHERE prt.ResetToken = @ResetToken
						AND u.Active = 1;
					
					-- Check if token exists
					IF @UserId IS NULL
					BEGIN
						RAISERROR('Invalid or expired reset token.', 16, 1);
						RETURN;
					END
					
					-- Check if token has already been used
					IF @TokenUsed = 1
					BEGIN
						RAISERROR('Reset token has already been used.', 16, 1);
						RETURN;
					END
					
					-- Check if token has expired
					IF @TokenExpiry < @CurrentTime
					BEGIN
						RAISERROR('Reset token has expired. Please request a new password reset.', 16, 1);
						RETURN;
					END
					
					-- Generate a new salt and hash the password
					SET @Salt = RIGHT(NEWID(), 12);
					SET @HashedPassword = CONVERT(NVARCHAR(255), HASHBYTES('SHA256', @NewPassword + @Salt), 2);
					
					-- Update user password
					UPDATE Users
					SET 
						PasswordHash = @HashedPassword,
						Salt = @Salt,
						PasswordChangedAt = @CurrentTime,
						LastPasswordReset = @CurrentTime,
						UpdatedAt = @CurrentTime,
						-- Reset failed login attempts since password was successfully reset
						LoginAttempts = 0,
						AccountLocked = 0
					WHERE UserId = @UserId;
					
					-- Mark the reset token as used
					UPDATE PasswordResetTokens
					SET 
						IsUsed = 1,
						UsedAt = @CurrentTime,
						UpdatedAt = @CurrentTime
					WHERE ResetToken = @ResetToken;
					
					-- Invalidate all existing sessions/tokens for this user (for security)
					UPDATE UserSessions
					SET 
						IsActive = 0,
						LoggedOutAt = @CurrentTime,
						UpdatedAt = @CurrentTime
					WHERE UserId = @UserId AND IsActive = 1;
					
					-- Log the password reset activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@UserId,
						'PASSWORD_RESET',
						'Password reset successfully using reset token',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Optional: Send notification email (placeholder for email service integration)
					-- This would typically trigger an email notification about successful password reset
					INSERT INTO UserNotifications (
						UserId,
						NotificationType,
						Title,
						Message,
						IsRead,
						CreatedAt
					) VALUES (
						@UserId,
						'SECURITY_ALERT',
						'Password Reset Successful',
						'Your password has been successfully reset. If you did not perform this action, please contact support immediately.',
						0,
						@CurrentTime
					);
					
					-- Return success information
					SELECT 
						@UserId AS UserId,
						@Email AS Email,
						'Password reset successfully' AS Message,
						@CurrentTime AS ResetDate;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed password reset attempt
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PASSWORD_RESET_FAILED',
							'Failed password reset attempt: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_USER_CART">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_USER_CART]
				@UserId BIGINT,
				@TenantId BIGINT = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Get cart items with full product details
					SELECT 
						-- Cart Information
						c.CartId,
						c.UserId,
						c.TenantId,
						c.Quantity,
						c.AddedDate,
						c.UpdatedDate,
						c.SessionId,
						
						-- Product Information
						p.ProductId,
						p.ProductName,
						p.ProductDescription,
						p.ProductCode,
						p.FullDescription,
						p.Specification,
						p.Story,
						p.PackQuantity,
						p.Quantity AS ProductAvailableQuantity,
						p.Total AS ProductTotal,
						p.Price,
						p.Category AS CategoryId,
						p.Rating,
						p.Active AS ProductActive,
						p.Trending,
						p.UserBuyCount,
						p.Return AS ReturnPolicy,
						p.Created AS ProductCreated,
						p.Modified AS ProductModified,
						p.InStock,
						p.BestSeller,
						p.DeliveryDate,
						p.Offer,
						p.OrderBy AS ProductOrderBy,
						p.UserId AS ProductUserId,
						p.Overview,
						p.LongDescription,
						
						-- Category Information
						cat.Category AS CategoryName,
						cat.Active AS CategoryActive,
						cat.OrderBy AS CategoryOrderBy,
						cat.Description AS CategoryDescription,
						cat.Icon AS CategoryIcon,
						cat.SubMenu AS CategorySubMenu,
						
						-- Calculated Fields
						(c.Quantity * p.Price) AS ItemTotal,
						CASE 
							WHEN p.Quantity >= c.Quantity THEN 1 
							ELSE 0 
						END AS IsAvailable,
						
						-- Product Images (will be handled in a separate query or joined)
						pi.ImageId,
						pi.Poster AS ImageUrl,
						pi.Main AS IsMainImage,
						pi.Active AS ImageActive,
						pi.OrderBy AS ImageOrderBy
						
					FROM CartItems c
					INNER JOIN Products p ON c.ProductId = p.ProductId
					LEFT JOIN ProductCategories cat ON p.Category = cat.CategoryId
					LEFT JOIN ProductImages pi ON p.ProductId = pi.ProductId AND pi.Active = 1
					WHERE c.UserId = @UserId 
						AND c.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR c.TenantId = @TenantId)
					ORDER BY c.AddedDate DESC, pi.OrderBy ASC;
					
					-- Get cart summary
					SELECT 
						COUNT(*) AS TotalItems,
						SUM(c.Quantity) AS TotalQuantity,
						SUM(c.Quantity * p.Price) AS TotalAmount,
						SUM(CASE WHEN p.Quantity >= c.Quantity THEN (c.Quantity * p.Price) ELSE 0 END) AS AvailableItemsTotal,
						COUNT(CASE WHEN p.Quantity < c.Quantity THEN 1 END) AS UnavailableItems
					FROM CartItems c
					INNER JOIN Products p ON c.ProductId = p.ProductId
					WHERE c.UserId = @UserId 
						AND c.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR c.TenantId = @TenantId);
						
					-- Get related/recommended products (optional - based on cart items)
					SELECT TOP 10
						p.ProductId,
						p.ProductName,
						p.Price,
						p.Rating,
						p.BestSeller,
						p.Offer,
						pi.Poster AS ImageUrl
					FROM Products p
					LEFT JOIN ProductImages pi ON p.ProductId = pi.ProductId AND pi.Main = 1 AND pi.Active = 1
					WHERE p.Active = 1
						AND p.ProductId NOT IN (
							SELECT c.ProductId 
							FROM CartItems c 
							WHERE c.UserId = @UserId AND c.Active = 1
						)
						AND p.Category IN (
							SELECT DISTINCT p2.Category
							FROM CartItems c2
							INNER JOIN Products p2 ON c2.ProductId = p2.ProductId
							WHERE c2.UserId = @UserId AND c2.Active = 1
						)
						AND (@TenantId IS NULL OR p.TenantId = @TenantId)
					ORDER BY p.Rating DESC, p.UserBuyCount DESC;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADD_ITEM_TO_CART">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADD_ITEM_TO_CART]
				@UserId BIGINT,
				@ProductId BIGINT,
				@Quantity INT,
				@TenantId BIGINT = NULL,
				@SessionId NVARCHAR(255) = NULL,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @ExistingCartId BIGINT = NULL;
					DECLARE @ExistingQuantity INT = 0;
					DECLARE @ProductPrice DECIMAL(18,2) = 0;
					DECLARE @ProductName NVARCHAR(255) = '';
					DECLARE @AvailableStock INT = 0;
					DECLARE @ProductActive BIT = 0;
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @NewQuantity INT = 0;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate product exists, is active, and get product details
					SELECT 
						@ProductPrice = Price,
						@ProductName = ProductName,
						@AvailableStock = Quantity,
						@ProductActive = Active
					FROM Products 
					WHERE ProductId = @ProductId
						AND (@TenantId IS NULL OR TenantId = @TenantId);
					
					IF @ProductActive IS NULL OR @ProductActive = 0
					BEGIN
						RAISERROR('Product not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate quantity is positive
					IF @Quantity <= 0
					BEGIN
						RAISERROR('Quantity must be greater than 0.', 16, 1);
						RETURN;
					END
					
					-- Check if item already exists in cart
					SELECT 
						@ExistingCartId = CartId,
						@ExistingQuantity = Quantity
					FROM CartItems 
					WHERE UserId = @UserId 
						AND ProductId = @ProductId 
						AND Active = 1
						AND (@TenantId IS NULL OR TenantId = @TenantId);
					
					-- Calculate new quantity
					SET @NewQuantity = @ExistingQuantity + @Quantity;
					
					-- Check stock availability
					IF @NewQuantity > @AvailableStock
					BEGIN
						RAISERROR('Insufficient stock. Available quantity: %d, Requested quantity: %d.', 16, 1, @AvailableStock, @NewQuantity);
						RETURN;
					END
					
					IF @ExistingCartId IS NOT NULL
					BEGIN
						-- Update existing cart item
						UPDATE CartItems
						SET 
							Quantity = @NewQuantity,
							UpdatedDate = @CurrentTime,
							SessionId = ISNULL(@SessionId, SessionId)
						WHERE CartId = @ExistingCartId;
						
						-- Log the cart update activity
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'CART_UPDATE',
							'Updated cart item: ' + @ProductName + ' (Quantity: ' + CAST(@NewQuantity AS VARCHAR(10)) + ')',
							@IpAddress,
							@UserAgent,
							@CurrentTime
						);
						
						-- Return updated cart item info
						SELECT 
							@ExistingCartId AS CartId,
							@UserId AS UserId,
							@ProductId AS ProductId,
							@ProductName AS ProductName,
							@NewQuantity AS Quantity,
							@ProductPrice AS Price,
							(@NewQuantity * @ProductPrice) AS ItemTotal,
							'Product quantity updated in cart' AS Message,
							@CurrentTime AS UpdatedDate;
					END
					ELSE
					BEGIN
						-- Insert new cart item
						INSERT INTO CartItems (
							UserId,
							ProductId,
							Quantity,
							TenantId,
							SessionId,
							Active,
							AddedDate,
							UpdatedDate
						) VALUES (
							@UserId,
							@ProductId,
							@Quantity,
							@TenantId,
							@SessionId,
							1,
							@CurrentTime,
							@CurrentTime
						);
						
						SET @ExistingCartId = SCOPE_IDENTITY();
						
						-- Log the cart addition activity
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'CART_ADD',
							'Added to cart: ' + @ProductName + ' (Quantity: ' + CAST(@Quantity AS VARCHAR(10)) + ')',
							@IpAddress,
							@UserAgent,
							@CurrentTime
						);
						
						-- Return new cart item info
						SELECT 
							@ExistingCartId AS CartId,
							@UserId AS UserId,
							@ProductId AS ProductId,
							@ProductName AS ProductName,
							@Quantity AS Quantity,
							@ProductPrice AS Price,
							(@Quantity * @ProductPrice) AS ItemTotal,
							'Product added to cart successfully' AS Message,
							@CurrentTime AS AddedDate;
					END
					
					-- Optional: Clean up old inactive cart items for this user (housekeeping)
					DELETE FROM CartItems 
					WHERE UserId = @UserId 
						AND Active = 0 
						AND UpdatedDate < DATEADD(DAY, -30, @CurrentTime);
					
					-- Get updated cart summary
					SELECT 
						COUNT(*) AS TotalUniqueItems,
						SUM(Quantity) AS TotalQuantity,
						SUM(ci.Quantity * p.Price) AS TotalAmount
					FROM CartItems ci
					INNER JOIN Products p ON ci.ProductId = p.ProductId
					WHERE ci.UserId = @UserId 
						AND ci.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR ci.TenantId = @TenantId);
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed cart operation
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'CART_ADD_FAILED',
							'Failed to add item to cart: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_REMOVE_ITEM_FROM_CART">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_REMOVE_ITEM_FROM_CART]
				@UserId BIGINT,
				@ProductId BIGINT,
				@TenantId BIGINT = NULL,
				@RemoveCompletely BIT = 1,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @ExistingCartId BIGINT = NULL;
					DECLARE @CurrentQuantity INT = 0;
					DECLARE @ProductName NVARCHAR(255) = '';
					DECLARE @ProductPrice DECIMAL(18,2) = 0;
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @RemovedQuantity INT = 0;
					DECLARE @ItemTotal DECIMAL(18,2) = 0;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Check if item exists in cart and get details
					SELECT 
						@ExistingCartId = ci.CartId,
						@CurrentQuantity = ci.Quantity,
						@ProductName = p.ProductName,
						@ProductPrice = p.Price
					FROM CartItems ci
					INNER JOIN Products p ON ci.ProductId = p.ProductId
					WHERE ci.UserId = @UserId 
						AND ci.ProductId = @ProductId 
						AND ci.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR ci.TenantId = @TenantId);
					
					-- Check if cart item exists
					IF @ExistingCartId IS NULL
					BEGIN
						RAISERROR('Product not found in cart.', 16, 1);
						RETURN;
					END
					
					-- Calculate removed quantity and item total
					SET @RemovedQuantity = @CurrentQuantity;
					SET @ItemTotal = @RemovedQuantity * @ProductPrice;
					
					-- Remove the item from cart (mark as inactive or delete)
					IF @RemoveCompletely = 1
					BEGIN
						-- Permanently delete the cart item
						DELETE FROM CartItems 
						WHERE CartId = @ExistingCartId;
					END
					ELSE
					BEGIN
						-- Mark as inactive (soft delete)
						UPDATE CartItems
						SET 
							Active = 0,
							UpdatedDate = @CurrentTime
						WHERE CartId = @ExistingCartId;
					END
					
					-- Log the cart removal activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@UserId,
						'CART_REMOVE',
						'Removed from cart: ' + @ProductName + ' (Quantity: ' + CAST(@RemovedQuantity AS VARCHAR(10)) + ')',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Return removed item details
					SELECT 
						@ExistingCartId AS CartId,
						@UserId AS UserId,
						@ProductId AS ProductId,
						@ProductName AS ProductName,
						@RemovedQuantity AS RemovedQuantity,
						@ProductPrice AS Price,
						@ItemTotal AS ItemTotal,
						'Product removed from cart successfully' AS Message,
						@CurrentTime AS RemovedDate;
					
					-- Get updated cart summary
					SELECT 
						COUNT(*) AS TotalUniqueItems,
						ISNULL(SUM(ci.Quantity), 0) AS TotalQuantity,
						ISNULL(SUM(ci.Quantity * p.Price), 0) AS TotalAmount
					FROM CartItems ci
					INNER JOIN Products p ON ci.ProductId = p.ProductId
					WHERE ci.UserId = @UserId 
						AND ci.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR ci.TenantId = @TenantId);
					
					-- Optional: Get recommended products to replace the removed item
					SELECT TOP 5
						p.ProductId,
						p.ProductName,
						p.Price,
						p.Rating,
						p.BestSeller,
						p.Offer,
						pi.Poster AS ImageUrl
					FROM Products p
					LEFT JOIN ProductImages pi ON p.ProductId = pi.ProductId AND pi.Main = 1 AND pi.Active = 1
					WHERE p.Active = 1
						AND p.ProductId != @ProductId  -- Exclude the removed product
						AND p.Category = (
							SELECT Category 
							FROM Products 
							WHERE ProductId = @ProductId
						)
						AND (@TenantId IS NULL OR p.TenantId = @TenantId)
					ORDER BY p.Rating DESC, p.UserBuyCount DESC;
					
					-- Optional: Clean up old inactive cart items for this user (housekeeping)
					DELETE FROM CartItems 
					WHERE UserId = @UserId 
						AND Active = 0 
						AND UpdatedDate < DATEADD(DAY, -30, @CurrentTime);
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed cart removal
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'CART_REMOVE_FAILED',
							'Failed to remove item from cart: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_CLEAR_CART">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_CLEAR_CART]
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@ClearCompletely BIT = 1,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CartItemCount INT = 0;
					DECLARE @TotalQuantity INT = 0;
					DECLARE @TotalValue DECIMAL(18,2) = 0;
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @AffectedRows INT = 0;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Get current cart statistics before clearing
					SELECT 
						@CartItemCount = COUNT(*),
						@TotalQuantity = ISNULL(SUM(ci.Quantity), 0),
						@TotalValue = ISNULL(SUM(ci.Quantity * p.Price), 0)
					FROM CartItems ci
					INNER JOIN Products p ON ci.ProductId = p.ProductId
					WHERE ci.UserId = @UserId 
						AND ci.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR ci.TenantId = @TenantId);
					
					-- Check if cart has any items
					IF @CartItemCount = 0
					BEGIN
						RAISERROR('Cart is already empty.', 16, 1);
						RETURN;
					END
					
					-- Clear the cart based on strategy
					IF @ClearCompletely = 1
					BEGIN
						-- Permanently delete all cart items
						DELETE FROM CartItems 
						WHERE UserId = @UserId 
							AND Active = 1
							AND (@TenantId IS NULL OR TenantId = @TenantId);
						
						SET @AffectedRows = @@ROWCOUNT;
					END
					ELSE
					BEGIN
						-- Mark all cart items as inactive (soft delete)
						UPDATE CartItems
						SET 
							Active = 0,
							UpdatedDate = @CurrentTime
						WHERE UserId = @UserId 
							AND Active = 1
							AND (@TenantId IS NULL OR TenantId = @TenantId);
						
						SET @AffectedRows = @@ROWCOUNT;
					END
					
					-- Verify that items were actually cleared
					IF @AffectedRows = 0
					BEGIN
						RAISERROR('Failed to clear cart items.', 16, 1);
						RETURN;
					END
					
					-- Log the cart clearing activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@UserId,
						'CART_CLEAR',
						'Cart cleared - ' + CAST(@CartItemCount AS VARCHAR(10)) + ' items removed (Total Value: $' + CAST(@TotalValue AS VARCHAR(20)) + ')',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Return clearing operation details
					SELECT 
						@UserId AS UserId,
						@CartItemCount AS ClearedItemCount,
						@TotalQuantity AS ClearedQuantity,
						@TotalValue AS ClearedValue,
						'Cart cleared successfully' AS Message,
						@CurrentTime AS ClearedDate,
						@ClearCompletely AS WasHardDelete;
					
					-- Get updated cart summary (should be empty)
					SELECT 
						COUNT(*) AS TotalUniqueItems,
						ISNULL(SUM(ci.Quantity), 0) AS TotalQuantity,
						ISNULL(SUM(ci.Quantity * p.Price), 0) AS TotalAmount
					FROM CartItems ci
					INNER JOIN Products p ON ci.ProductId = p.ProductId
					WHERE ci.UserId = @UserId 
						AND ci.Active = 1
						AND p.Active = 1
						AND (@TenantId IS NULL OR ci.TenantId = @TenantId);
					
					-- Optional: Get popular products for cart rebuilding suggestions
					SELECT TOP 10
						p.ProductId,
						p.ProductName,
						p.Price,
						p.Rating,
						p.BestSeller,
						p.Trending,
						p.UserBuyCount,
						p.Offer,
						pi.Poster AS ImageUrl,
						cat.Category AS CategoryName
					FROM Products p
					LEFT JOIN ProductImages pi ON p.ProductId = pi.ProductId AND pi.Main = 1 AND pi.Active = 1
					LEFT JOIN ProductCategories cat ON p.Category = cat.CategoryId
					WHERE p.Active = 1
						AND p.InStock = 1
						AND (@TenantId IS NULL OR p.TenantId = @TenantId)
					ORDER BY 
						p.BestSeller DESC,
						p.Rating DESC, 
						p.UserBuyCount DESC,
						p.Trending DESC;
					
					-- Optional: Clean up old inactive cart items for this user (housekeeping)
					DELETE FROM CartItems 
					WHERE UserId = @UserId 
						AND Active = 0 
						AND UpdatedDate < DATEADD(DAY, -30, @CurrentTime);
					
					-- Optional: Record user behavior for analytics
					INSERT INTO UserBehaviorAnalytics (
						UserId,
						ActionType,
						ActionDetails,
						ItemCount,
						TotalValue,
						CreatedAt
					) VALUES (
						@UserId,
						'CART_CLEARED',
						'User cleared entire cart',
						@CartItemCount,
						@TotalValue,
						@CurrentTime
					);
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed cart clearing
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'CART_CLEAR_FAILED',
							'Failed to clear cart: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_CREATE_ORDER">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_CREATE_ORDER]
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@OrderItems NVARCHAR(MAX), -- JSON string containing order items
				@ShippingAddress NVARCHAR(MAX), -- JSON string containing shipping address
				@BillingAddress NVARCHAR(MAX), -- JSON string containing billing address
				@PaymentMethod NVARCHAR(MAX), -- JSON string containing payment method
				@ShippingMethod NVARCHAR(MAX), -- JSON string containing shipping method
				@OrderTotals NVARCHAR(MAX), -- JSON string containing order totals
				@Notes NVARCHAR(1000) = NULL,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @OrderId BIGINT;
					DECLARE @OrderNumber NVARCHAR(50);
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @OrderStatus NVARCHAR(50) = 'Pending';
					DECLARE @PaymentStatus NVARCHAR(50) = 'Pending';
					DECLARE @TotalAmount DECIMAL(18,2) = 0;
					DECLARE @ItemCount INT = 0;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Parse order totals to get total amount
					IF @OrderTotals IS NOT NULL
					BEGIN
						SELECT @TotalAmount = CAST(JSON_VALUE(@OrderTotals, '$.total') AS DECIMAL(18,2));
					END
					
					-- Generate unique order number
					SET @OrderNumber = 'ORD' + FORMAT(@CurrentTime, 'yyyyMMdd') + FORMAT(ABS(CHECKSUM(NEWID())) % 100000, '00000');
					
					-- Ensure order number is unique
					WHILE EXISTS (SELECT 1 FROM Orders WHERE OrderNumber = @OrderNumber)
					BEGIN
						SET @OrderNumber = 'ORD' + FORMAT(@CurrentTime, 'yyyyMMdd') + FORMAT(ABS(CHECKSUM(NEWID())) % 100000, '00000');
					END
					
					-- Insert main order record
					INSERT INTO Orders (
						UserId,
						TenantId,
						OrderNumber,
						OrderStatus,
						PaymentStatus,
						TotalAmount,
						Subtotal,
						ShippingAmount,
						TaxAmount,
						DiscountAmount,
						Notes,
						ShippingAddress,
						BillingAddress,
						PaymentMethod,
						ShippingMethod,
						CreatedAt,
						UpdatedAt,
						Active
					)
					SELECT 
						@UserId,
						@TenantId,
						@OrderNumber,
						@OrderStatus,
						@PaymentStatus,
						@TotalAmount,
						CAST(JSON_VALUE(@OrderTotals, '$.subtotal') AS DECIMAL(18,2)),
						CAST(JSON_VALUE(@OrderTotals, '$.shipping') AS DECIMAL(18,2)),
						CAST(JSON_VALUE(@OrderTotals, '$.tax') AS DECIMAL(18,2)),
						CAST(JSON_VALUE(@OrderTotals, '$.discount') AS DECIMAL(18,2)),
						@Notes,
						@ShippingAddress,
						@BillingAddress,
						@PaymentMethod,
						@ShippingMethod,
						@CurrentTime,
						@CurrentTime,
						1;
					
					SET @OrderId = SCOPE_IDENTITY();
					
					-- Insert order items from JSON
					INSERT INTO OrderItems (
						OrderId,
						ProductId,
						ProductName,
						ProductImage,
						Price,
						Quantity,
						Total,
						CreatedAt,
						Active
					)
					SELECT 
						@OrderId,
						CAST(JSON_VALUE(value, '$.productId') AS BIGINT),
						JSON_VALUE(value, '$.productName'),
						JSON_VALUE(value, '$.productImage'),
						CAST(JSON_VALUE(value, '$.price') AS DECIMAL(18,2)),
						CAST(JSON_VALUE(value, '$.quantity') AS INT),
						CAST(JSON_VALUE(value, '$.total') AS DECIMAL(18,2)),
						@CurrentTime,
						1
					FROM OPENJSON(@OrderItems);
					
					-- Get item count
					SELECT @ItemCount = COUNT(*) FROM OrderItems WHERE OrderId = @OrderId AND Active = 1;
					
					-- Validate that we have items
					IF @ItemCount = 0
					BEGIN
						RAISERROR('Order must contain at least one item.', 16, 1);
						RETURN;
					END
					
					-- Update product inventory (reduce stock)
					UPDATE p
					SET 
						p.Quantity = p.Quantity - oi.Quantity,
						p.UserBuyCount = p.UserBuyCount + oi.Quantity,
						p.Modified = @CurrentTime
					FROM Products p
					INNER JOIN OrderItems oi ON p.ProductId = oi.ProductId
					WHERE oi.OrderId = @OrderId 
						AND oi.Active = 1
						AND p.Active = 1;
					
					-- Check for insufficient stock
					IF EXISTS (
						SELECT 1 
						FROM Products p
						INNER JOIN OrderItems oi ON p.ProductId = oi.ProductId
						WHERE oi.OrderId = @OrderId 
							AND p.Quantity < 0
					)
					BEGIN
						RAISERROR('Insufficient stock for one or more products.', 16, 1);
						RETURN;
					END
					
					-- Clear user's cart items that were ordered
					UPDATE CartItems
					SET 
						Active = 0,
						UpdatedDate = @CurrentTime
					WHERE UserId = @UserId 
						AND ProductId IN (
							SELECT ProductId 
							FROM OrderItems 
							WHERE OrderId = @OrderId AND Active = 1
						)
						AND Active = 1
						AND (@TenantId IS NULL OR TenantId = @TenantId);
					
					-- Log the order creation activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@UserId,
						'ORDER_CREATED',
						'Order created: ' + @OrderNumber + ' (Items: ' + CAST(@ItemCount AS VARCHAR(10)) + ', Total: $' + CAST(@TotalAmount AS VARCHAR(20)) + ')',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Record order analytics
					INSERT INTO OrderAnalytics (
						OrderId,
						UserId,
						OrderNumber,
						TotalAmount,
						ItemCount,
						OrderDate,
						TenantId,
						CreatedAt
					) VALUES (
						@OrderId,
						@UserId,
						@OrderNumber,
						@TotalAmount,
						@ItemCount,
						@CurrentTime,
						@TenantId,
						@CurrentTime
					);
					
					-- Send order confirmation (placeholder for email/notification)
					INSERT INTO NotificationQueue (
						UserId,
						NotificationType,
						Subject,
						Message,
						OrderId,
						CreatedAt,
						Status
					) VALUES (
						@UserId,
						'ORDER_CONFIRMATION',
						'Order Confirmation - ' + @OrderNumber,
						'Your order has been successfully placed. Order Number: ' + @OrderNumber,
						@OrderId,
						@CurrentTime,
						'Pending'
					);
					
					-- Return order creation details
					SELECT 
						@OrderId AS OrderId,
						@OrderNumber AS OrderNumber,
						@UserId AS UserId,
						@ItemCount AS ItemCount,
						@TotalAmount AS TotalAmount,
						@OrderStatus AS OrderStatus,
						@PaymentStatus AS PaymentStatus,
						'Order created successfully' AS Message,
						@CurrentTime AS CreatedDate;
					
					-- Return order summary
					SELECT 
						o.OrderId,
						o.OrderNumber,
						o.TotalAmount,
						o.OrderStatus,
						o.PaymentStatus,
						o.CreatedAt,
						COUNT(oi.OrderItemId) AS TotalItems,
						SUM(oi.Quantity) AS TotalQuantity
					FROM Orders o
					LEFT JOIN OrderItems oi ON o.OrderId = oi.OrderId AND oi.Active = 1
					WHERE o.OrderId = @OrderId
					GROUP BY o.OrderId, o.OrderNumber, o.TotalAmount, o.OrderStatus, o.PaymentStatus, o.CreatedAt;
					
					-- Return order items
					SELECT 
						oi.OrderItemId,
						oi.ProductId,
						oi.ProductName,
						oi.ProductImage,
						oi.Price,
						oi.Quantity,
						oi.Total,
						p.ProductCode,
						p.Category
					FROM OrderItems oi
					LEFT JOIN Products p ON oi.ProductId = p.ProductId
					WHERE oi.OrderId = @OrderId AND oi.Active = 1
					ORDER BY oi.OrderItemId;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed order creation
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'ORDER_CREATE_FAILED',
							'Failed to create order: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_ORDERS">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_ORDERS]
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@Page INT = 1,
				@Limit INT = 10,
				@Status NVARCHAR(50) = NULL,
				@Search NVARCHAR(100) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					DECLARE @Offset INT;
					DECLARE @TotalCount INT;
					
					-- Calculate offset for pagination
					SET @Offset = (@Page - 1) * @Limit;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Get total count for pagination
					SELECT @TotalCount = COUNT(*)
					FROM Orders o
					WHERE o.UserId = @UserId
						AND o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
						AND (@Status IS NULL OR o.OrderStatus = @Status)
						AND (@Search IS NULL OR o.OrderNumber LIKE '%' + @Search + '%');
					
					-- Get orders with pagination
					SELECT 
						o.OrderId,
						o.OrderNumber,
						o.OrderStatus,
						o.PaymentStatus,
						o.TotalAmount,
						o.Subtotal,
						o.ShippingAmount,
						o.TaxAmount,
						o.DiscountAmount,
						o.Notes,
						o.CreatedAt,
						o.UpdatedAt,
						-- Calculate item count and total quantity
						COUNT(oi.OrderItemId) AS TotalItems,
						ISNULL(SUM(oi.Quantity), 0) AS TotalQuantity,
						-- Pagination info
						@TotalCount AS TotalCount,
						@Page AS CurrentPage,
						@Limit AS PageSize,
						CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
						CASE WHEN @Page < CEILING(CAST(@TotalCount AS FLOAT) / @Limit) THEN 1 ELSE 0 END AS HasNext,
						CASE WHEN @Page > 1 THEN 1 ELSE 0 END AS HasPrevious
					FROM Orders o
					LEFT JOIN OrderItems oi ON o.OrderId = oi.OrderId AND oi.Active = 1
					WHERE o.UserId = @UserId
						AND o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
						AND (@Status IS NULL OR o.OrderStatus = @Status)
						AND (@Search IS NULL OR o.OrderNumber LIKE '%' + @Search + '%')
					GROUP BY o.OrderId, o.OrderNumber, o.OrderStatus, o.PaymentStatus, o.TotalAmount, 
							 o.Subtotal, o.ShippingAmount, o.TaxAmount, o.DiscountAmount, o.Notes, 
							 o.CreatedAt, o.UpdatedAt
					ORDER BY o.CreatedAt DESC
					OFFSET @Offset ROWS
					FETCH NEXT @Limit ROWS ONLY;
					
					-- Get order items for each order in the result set
					SELECT 
						oi.OrderId,
						oi.OrderItemId,
						oi.ProductId,
						oi.ProductName,
						oi.ProductImage,
						oi.Price,
						oi.Quantity,
						oi.Total,
						p.ProductCode,
						p.Category,
						p.Rating,
						p.Offer
					FROM OrderItems oi
					LEFT JOIN Products p ON oi.ProductId = p.ProductId
					WHERE oi.OrderId IN (
						SELECT o.OrderId
						FROM Orders o
						WHERE o.UserId = @UserId
							AND o.Active = 1
							AND (@TenantId IS NULL OR o.TenantId = @TenantId)
							AND (@Status IS NULL OR o.OrderStatus = @Status)
							AND (@Search IS NULL OR o.OrderNumber LIKE '%' + @Search + '%')
						ORDER BY o.CreatedAt DESC
						OFFSET @Offset ROWS
						FETCH NEXT @Limit ROWS ONLY
					)
					AND oi.Active = 1
					ORDER BY oi.OrderId, oi.OrderItemId;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_GET_ORDER_BY_ID">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_GET_ORDER_BY_ID]
				@OrderId BIGINT,
				@UserId BIGINT,
				@TenantId BIGINT = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate order exists and belongs to user
					IF NOT EXISTS (
						SELECT 1 FROM Orders 
						WHERE OrderId = @OrderId 
							AND UserId = @UserId 
							AND Active = 1
							AND (@TenantId IS NULL OR TenantId = @TenantId)
					)
					BEGIN
						RAISERROR('Order not found or does not belong to user.', 16, 1);
						RETURN;
					END
					
					-- Get order details
					SELECT 
						o.OrderId,
						o.OrderNumber,
						o.OrderStatus,
						o.PaymentStatus,
						o.TotalAmount,
						o.Subtotal,
						o.ShippingAmount,
						o.TaxAmount,
						o.DiscountAmount,
						o.Notes,
						o.ShippingAddress,
						o.BillingAddress,
						o.PaymentMethod,
						o.ShippingMethod,
						o.CreatedAt,
						o.UpdatedAt,
						-- User information
						u.FirstName + ' ' + u.LastName AS CustomerName,
						u.Email AS CustomerEmail,
						u.Phone AS CustomerPhone,
						-- Calculate totals
						COUNT(oi.OrderItemId) AS TotalItems,
						ISNULL(SUM(oi.Quantity), 0) AS TotalQuantity
					FROM Orders o
					LEFT JOIN Users u ON o.UserId = u.UserId
					LEFT JOIN OrderItems oi ON o.OrderId = oi.OrderId AND oi.Active = 1
					WHERE o.OrderId = @OrderId
						AND o.UserId = @UserId
						AND o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
					GROUP BY o.OrderId, o.OrderNumber, o.OrderStatus, o.PaymentStatus, o.TotalAmount,
							 o.Subtotal, o.ShippingAmount, o.TaxAmount, o.DiscountAmount, o.Notes,
							 o.ShippingAddress, o.BillingAddress, o.PaymentMethod, o.ShippingMethod,
							 o.CreatedAt, o.UpdatedAt, u.FirstName, u.LastName, u.Email, u.Phone;
					
					-- Get order items
					SELECT 
						oi.OrderItemId,
						oi.ProductId,
						oi.ProductName,
						oi.ProductImage,
						oi.Price,
						oi.Quantity,
						oi.Total,
						oi.CreatedAt,
						-- Product details
						p.ProductCode,
						p.ProductDescription,
						p.Category,
						p.Rating,
						p.Offer,
						p.InStock,
						p.BestSeller
					FROM OrderItems oi
					LEFT JOIN Products p ON oi.ProductId = p.ProductId
					WHERE oi.OrderId = @OrderId
						AND oi.Active = 1
					ORDER BY oi.OrderItemId;
					
					-- Get order status history (if available)
					SELECT 
						osh.StatusHistoryId,
						osh.PreviousStatus,
						osh.NewStatus,
						osh.StatusNote,
						osh.ChangedBy,
						osh.ChangedAt,
						u.FirstName + ' ' + u.LastName AS ChangedByName
					FROM OrderStatusHistory osh
					LEFT JOIN Users u ON osh.ChangedBy = u.UserId
					WHERE osh.OrderId = @OrderId
					ORDER BY osh.ChangedAt DESC;
					
					-- Get order tracking information (if available)
					SELECT 
						ot.TrackingId,
						ot.TrackingNumber,
						ot.Carrier,
						ot.TrackingStatus,
						ot.EstimatedDelivery,
						ot.ActualDelivery,
						ot.TrackingUrl,
						ot.CreatedAt,
						ot.UpdatedAt
					FROM OrderTracking ot
					WHERE ot.OrderId = @OrderId
						AND ot.Active = 1
					ORDER BY ot.CreatedAt DESC;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_CANCEL_ORDER">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_CANCEL_ORDER]
				@OrderId BIGINT,
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@CancelReason NVARCHAR(500) = NULL,
				@CancelledBy BIGINT = NULL,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentStatus NVARCHAR(50);
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @OrderNumber NVARCHAR(50);
					DECLARE @TotalAmount DECIMAL(18,2);
					DECLARE @RefundAmount DECIMAL(18,2) = 0;
					DECLARE @CanCancel BIT = 0;
					
					-- Validate user exists and is active
					IF NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate order exists and belongs to user
					SELECT 
						@CurrentStatus = OrderStatus,
						@OrderNumber = OrderNumber,
						@TotalAmount = TotalAmount
					FROM Orders 
					WHERE OrderId = @OrderId 
						AND UserId = @UserId 
						AND Active = 1
						AND (@TenantId IS NULL OR TenantId = @TenantId);
					
					IF @CurrentStatus IS NULL
					BEGIN
						RAISERROR('Order not found or does not belong to user.', 16, 1);
						RETURN;
					END
					
					-- Check if order can be cancelled based on current status
					IF @CurrentStatus IN ('Pending', 'Confirmed', 'Processing')
					BEGIN
						SET @CanCancel = 1;
						SET @RefundAmount = @TotalAmount; -- Full refund for early stage cancellations
					END
					ELSE IF @CurrentStatus = 'Shipped'
					BEGIN
						SET @CanCancel = 1;
						SET @RefundAmount = @TotalAmount * 0.95; -- 95% refund for shipped orders (5% handling fee)
					END
					ELSE IF @CurrentStatus IN ('Delivered', 'Cancelled', 'Refunded', 'Returned')
					BEGIN
						SET @CanCancel = 0;
					END
					
					IF @CanCancel = 0
					BEGIN
						RAISERROR('Order cannot be cancelled in current status: %s', 16, 1, @CurrentStatus);
						RETURN;
					END
					
					-- Update order status to cancelled
					UPDATE Orders
					SET 
						OrderStatus = 'Cancelled',
						PaymentStatus = CASE 
							WHEN PaymentStatus = 'Paid' THEN 'Refund_Pending'
							ELSE PaymentStatus
						END,
						UpdatedAt = @CurrentTime,
						CancelledAt = @CurrentTime,
						CancelReason = @CancelReason,
						CancelledBy = ISNULL(@CancelledBy, @UserId)
					WHERE OrderId = @OrderId;
					
					-- Add status history record
					INSERT INTO OrderStatusHistory (
						OrderId,
						PreviousStatus,
						NewStatus,
						StatusNote,
						ChangedBy,
						ChangedAt,
						CreatedAt
					) VALUES (
						@OrderId,
						@CurrentStatus,
						'Cancelled',
						ISNULL(@CancelReason, 'Order cancelled by customer'),
						ISNULL(@CancelledBy, @UserId),
						@CurrentTime,
						@CurrentTime
					);
					
					-- Restore product inventory
					UPDATE p
					SET 
						p.Quantity = p.Quantity + oi.Quantity,
						p.UserBuyCount = CASE 
							WHEN p.UserBuyCount >= oi.Quantity THEN p.UserBuyCount - oi.Quantity
							ELSE 0
						END,
						p.Modified = @CurrentTime
					FROM Products p
					INNER JOIN OrderItems oi ON p.ProductId = oi.ProductId
					WHERE oi.OrderId = @OrderId 
						AND oi.Active = 1
						AND p.Active = 1;
					
					-- Create refund record if payment was made
					IF EXISTS (SELECT 1 FROM Orders WHERE OrderId = @OrderId AND PaymentStatus IN ('Paid', 'Refund_Pending'))
					BEGIN
						INSERT INTO OrderRefunds (
							OrderId,
							RefundAmount,
							RefundReason,
							RefundStatus,
							RefundMethod,
							RequestedBy,
							RequestedAt,
							CreatedAt,
							Active
						) VALUES (
							@OrderId,
							@RefundAmount,
							ISNULL(@CancelReason, 'Order cancellation'),
							'Pending',
							'Original_Payment_Method',
							ISNULL(@CancelledBy, @UserId),
							@CurrentTime,
							@CurrentTime,
							1
						);
					END
					
					-- Log the cancellation activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@UserId,
						'ORDER_CANCELLED',
						'Order cancelled: ' + @OrderNumber + ' (Reason: ' + ISNULL(@CancelReason, 'Customer request') + ')',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Queue cancellation notification
					INSERT INTO NotificationQueue (
						UserId,
						NotificationType,
						Subject,
						Message,
						OrderId,
						CreatedAt,
						Status
					) VALUES (
						@UserId,
						'ORDER_CANCELLED',
						'Order Cancellation Confirmation - ' + @OrderNumber,
						'Your order has been successfully cancelled. ' + 
						CASE WHEN @RefundAmount > 0 THEN 'Refund of $' + CAST(@RefundAmount AS VARCHAR(20)) + ' will be processed.' ELSE '' END,
						@OrderId,
						@CurrentTime,
						'Pending'
					);
					
					-- Return cancellation details
					SELECT 
						@OrderId AS OrderId,
						@OrderNumber AS OrderNumber,
						@UserId AS UserId,
						@CurrentStatus AS PreviousStatus,
						'Cancelled' AS NewStatus,
						@RefundAmount AS RefundAmount,
						ISNULL(@CancelReason, 'Order cancelled by customer') AS CancelReason,
						'Order cancelled successfully' AS Message,
						@CurrentTime AS CancelledDate,
						CASE WHEN @RefundAmount > 0 THEN 1 ELSE 0 END AS RefundInitiated;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed cancellation
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'ORDER_CANCEL_FAILED',
							'Failed to cancel order: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_UPDATE_ORDER_STATUS">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_UPDATE_ORDER_STATUS]
				@OrderId BIGINT,
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@NewStatus NVARCHAR(50),
				@StatusNote NVARCHAR(1000) = NULL,
				@TrackingNumber NVARCHAR(100) = NULL,
				@Carrier NVARCHAR(100) = NULL,
				@EstimatedDelivery DATETIME = NULL,
				@UpdatedBy BIGINT = NULL,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentStatus NVARCHAR(50);
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @OrderNumber NVARCHAR(50);
					DECLARE @PaymentStatus NVARCHAR(50);
					DECLARE @IsValidTransition BIT = 0;
					DECLARE @TrackingId BIGINT;
					
					-- Validate user exists and is active (for customer updates)
					IF @UserId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate order exists
					SELECT 
						@CurrentStatus = OrderStatus,
						@OrderNumber = OrderNumber,
						@PaymentStatus = PaymentStatus
					FROM Orders 
					WHERE OrderId = @OrderId 
						AND (@UserId IS NULL OR UserId = @UserId)  -- Allow admin updates without user restriction
						AND Active = 1
						AND (@TenantId IS NULL OR TenantId = @TenantId);
					
					IF @CurrentStatus IS NULL
					BEGIN
						RAISERROR('Order not found or access denied.', 16, 1);
						RETURN;
					END
					
					-- Validate status transition
					IF (@CurrentStatus = 'Pending' AND @NewStatus IN ('Confirmed', 'Cancelled'))
						OR (@CurrentStatus = 'Confirmed' AND @NewStatus IN ('Processing', 'Cancelled'))
						OR (@CurrentStatus = 'Processing' AND @NewStatus IN ('Shipped', 'Cancelled'))
						OR (@CurrentStatus = 'Shipped' AND @NewStatus IN ('Delivered', 'Returned'))
						OR (@CurrentStatus = 'Delivered' AND @NewStatus = 'Returned')
						OR (@CurrentStatus = @NewStatus) -- Allow same status with note updates
					BEGIN
						SET @IsValidTransition = 1;
					END
					
					IF @IsValidTransition = 0
					BEGIN
						RAISERROR('Invalid status transition from %s to %s', 16, 1, @CurrentStatus, @NewStatus);
						RETURN;
					END
					
					-- Update order status
					UPDATE Orders
					SET 
						OrderStatus = @NewStatus,
						UpdatedAt = @CurrentTime,
						-- Update specific fields based on status
						ShippedAt = CASE WHEN @NewStatus = 'Shipped' THEN @CurrentTime ELSE ShippedAt END,
						DeliveredAt = CASE WHEN @NewStatus = 'Delivered' THEN @CurrentTime ELSE DeliveredAt END,
						PaymentStatus = CASE 
							WHEN @NewStatus = 'Delivered' AND @PaymentStatus = 'Pending' THEN 'Paid'
							ELSE @PaymentStatus
						END
					WHERE OrderId = @OrderId;
					
					-- Add status history record
					INSERT INTO OrderStatusHistory (
						OrderId,
						PreviousStatus,
						NewStatus,
						StatusNote,
						ChangedBy,
						ChangedAt,
						CreatedAt
					) VALUES (
						@OrderId,
						@CurrentStatus,
						@NewStatus,
						@StatusNote,
						ISNULL(@UpdatedBy, @UserId),
						@CurrentTime,
						@CurrentTime
					);
					
					-- Handle tracking information for shipped status
					IF @NewStatus = 'Shipped' AND @TrackingNumber IS NOT NULL
					BEGIN
						-- Check if tracking record exists
						SELECT @TrackingId = TrackingId 
						FROM OrderTracking 
						WHERE OrderId = @OrderId AND Active = 1;
						
						IF @TrackingId IS NOT NULL
						BEGIN
							-- Update existing tracking record
							UPDATE OrderTracking
							SET 
								TrackingNumber = @TrackingNumber,
								Carrier = ISNULL(@Carrier, Carrier),
								TrackingStatus = 'Shipped',
								EstimatedDelivery = ISNULL(@EstimatedDelivery, EstimatedDelivery),
								UpdatedAt = @CurrentTime
							WHERE TrackingId = @TrackingId;
						END
						ELSE
						BEGIN
							-- Create new tracking record
							INSERT INTO OrderTracking (
								OrderId,
								TrackingNumber,
								Carrier,
								TrackingStatus,
								EstimatedDelivery,
								TrackingUrl,
								CreatedAt,
								UpdatedAt,
								Active
							) VALUES (
								@OrderId,
								@TrackingNumber,
								@Carrier,
								'Shipped',
								@EstimatedDelivery,
								CASE 
									WHEN @Carrier = 'FedEx' THEN 'https://fedex.com/track/' + @TrackingNumber
									WHEN @Carrier = 'UPS' THEN 'https://ups.com/track/' + @TrackingNumber
									WHEN @Carrier = 'DHL' THEN 'https://dhl.com/track/' + @TrackingNumber
									ELSE NULL
								END,
								@CurrentTime,
								@CurrentTime,
								1
							);
						END
					END
					
					-- Update tracking status for delivered orders
					IF @NewStatus = 'Delivered'
					BEGIN
						UPDATE OrderTracking
						SET 
							TrackingStatus = 'Delivered',
							ActualDelivery = @CurrentTime,
							UpdatedAt = @CurrentTime
						WHERE OrderId = @OrderId AND Active = 1;
					END
					
					-- Log the status update activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						ISNULL(@UserId, @UpdatedBy),
						'ORDER_STATUS_UPDATED',
						'Order status updated: ' + @OrderNumber + ' (' + @CurrentStatus + ' → ' + @NewStatus + ')',
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Queue status update notification
					INSERT INTO NotificationQueue (
						UserId,
						NotificationType,
						Subject,
						Message,
						OrderId,
						CreatedAt,
						Status
					) VALUES (
						@UserId,
						'ORDER_STATUS_UPDATE',
						'Order Status Update - ' + @OrderNumber,
						'Your order status has been updated to: ' + @NewStatus + 
						CASE 
							WHEN @TrackingNumber IS NOT NULL THEN '. Tracking Number: ' + @TrackingNumber
							ELSE ''
						END,
						@OrderId,
						@CurrentTime,
						'Pending'
					);
					
					-- Return status update details
					SELECT 
						@OrderId AS OrderId,
						@OrderNumber AS OrderNumber,
						ISNULL(@UserId, @UpdatedBy) AS UserId,
						@CurrentStatus AS PreviousStatus,
						@NewStatus AS NewStatus,
						@TrackingNumber AS TrackingNumber,
						@Carrier AS Carrier,
						@EstimatedDelivery AS EstimatedDelivery,
						ISNULL(@StatusNote, 'Order status updated') AS StatusNote,
						'Order status updated successfully' AS Message,
						@CurrentTime AS UpdatedDate;
					
					-- Return updated tracking info if available
					SELECT 
						t.TrackingId,
						t.TrackingNumber,
						t.Carrier,
						t.TrackingStatus,
						t.EstimatedDelivery,
						t.ActualDelivery,
						t.TrackingUrl,
						t.UpdatedAt
					FROM OrderTracking t
					WHERE t.OrderId = @OrderId AND t.Active = 1;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed status update
					IF @UserId IS NOT NULL OR @UpdatedBy IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							ISNULL(@UserId, @UpdatedBy),
							'ORDER_STATUS_UPDATE_FAILED',
							'Failed to update order status: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADMIN_GET_ALL_USERS">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADMIN_GET_ALL_USERS]
				@AdminUserId BIGINT,
				@TenantId BIGINT = NULL,
				@Page INT = 1,
				@Limit INT = 10,
				@Search NVARCHAR(100) = NULL,
				@Role NVARCHAR(50) = NULL,
				@Status NVARCHAR(50) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					DECLARE @Offset INT;
					DECLARE @TotalCount INT;
					
					-- Calculate offset for pagination
					SET @Offset = (@Page - 1) * @Limit;
					
					-- Validate admin user exists and has admin role
					IF NOT EXISTS (
						SELECT 1 FROM Users u
						INNER JOIN UserRoles ur ON u.UserId = ur.UserId
						INNER JOIN Roles r ON ur.RoleId = r.RoleId
						WHERE u.UserId = @AdminUserId 
							AND u.Active = 1 
							AND r.RoleName IN ('Admin', 'SuperAdmin')
							AND ur.Active = 1
					)
					BEGIN
						RAISERROR('User not found or insufficient privileges.', 16, 1);
						RETURN;
					END
					
					-- Get total count for pagination
					SELECT @TotalCount = COUNT(DISTINCT u.UserId)
					FROM Users u
					LEFT JOIN UserRoles ur ON u.UserId = ur.UserId AND ur.Active = 1
					LEFT JOIN Roles r ON ur.RoleId = r.RoleId AND r.Active = 1
					WHERE u.Active = 1
						AND (@TenantId IS NULL OR u.TenantId = @TenantId)
						AND (@Search IS NULL OR u.FirstName + ' ' + u.LastName LIKE '%' + @Search + '%' OR u.Email LIKE '%' + @Search + '%')
						AND (@Role IS NULL OR r.RoleName = @Role)
						AND (@Status IS NULL OR 
							(@Status = 'active' AND u.Active = 1 AND u.AccountLocked = 0) OR
							(@Status = 'locked' AND u.AccountLocked = 1) OR
							(@Status = 'inactive' AND u.Active = 0)
						);
					
					-- Get users with pagination
					SELECT 
						u.UserId AS Id,
						u.FirstName + ' ' + u.LastName AS Name,
						u.Email,
						u.Phone,
						ISNULL(r.RoleName, 'customer') AS Role,
						CASE WHEN u.EmailVerified = 1 THEN 1 ELSE 0 END AS EmailVerified,
						CASE WHEN u.PhoneVerified = 1 THEN 1 ELSE 0 END AS PhoneVerified,
						CASE 
							WHEN u.Active = 0 THEN 'inactive'
							WHEN u.AccountLocked = 1 THEN 'locked'
							ELSE 'active'
						END AS Status,
						u.CreatedAt,
						u.LastLogin,
						u.TenantId,
						u.DateOfBirth,
						u.Gender,
						u.Country,
						u.City,
						u.State,
						u.PostalCode,
						u.CompanyName,
						u.JobTitle,
						-- Calculate order statistics
						ISNULL(orderStats.OrderCount, 0) AS OrderCount,
						ISNULL(orderStats.TotalSpent, 0) AS TotalSpent,
						ISNULL(orderStats.LastOrderDate, NULL) AS LastOrderDate,
						-- Pagination info
						@TotalCount AS TotalCount,
						@Page AS CurrentPage,
						@Limit AS PageSize,
						CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
						CASE WHEN @Page < CEILING(CAST(@TotalCount AS FLOAT) / @Limit) THEN 1 ELSE 0 END AS HasNext,
						CASE WHEN @Page > 1 THEN 1 ELSE 0 END AS HasPrevious
					FROM Users u
					LEFT JOIN UserRoles ur ON u.UserId = ur.UserId AND ur.Active = 1
					LEFT JOIN Roles r ON ur.RoleId = r.RoleId AND r.Active = 1
					LEFT JOIN (
						SELECT 
							o.UserId,
							COUNT(o.OrderId) AS OrderCount,
							SUM(o.TotalAmount) AS TotalSpent,
							MAX(o.CreatedAt) AS LastOrderDate
						FROM Orders o
						WHERE o.Active = 1
						GROUP BY o.UserId
					) orderStats ON u.UserId = orderStats.UserId
					WHERE u.Active = 1
						AND (@TenantId IS NULL OR u.TenantId = @TenantId)
						AND (@Search IS NULL OR u.FirstName + ' ' + u.LastName LIKE '%' + @Search + '%' OR u.Email LIKE '%' + @Search + '%')
						AND (@Role IS NULL OR r.RoleName = @Role)
						AND (@Status IS NULL OR 
							(@Status = 'active' AND u.Active = 1 AND u.AccountLocked = 0) OR
							(@Status = 'locked' AND u.AccountLocked = 1) OR
							(@Status = 'inactive' AND u.Active = 0)
						)
					ORDER BY u.CreatedAt DESC
					OFFSET @Offset ROWS
					FETCH NEXT @Limit ROWS ONLY;
					
					-- Get user permissions for each user in the result set
					SELECT 
						u.UserId,
						p.PermissionName,
						p.PermissionDescription
					FROM Users u
					INNER JOIN UserRoles ur ON u.UserId = ur.UserId AND ur.Active = 1
					INNER JOIN RolePermissions rp ON ur.RoleId = rp.RoleId AND rp.Active = 1
					INNER JOIN Permissions p ON rp.PermissionId = p.PermissionId AND p.Active = 1
					WHERE u.UserId IN (
						SELECT u2.UserId
						FROM Users u2
						LEFT JOIN UserRoles ur2 ON u2.UserId = ur2.UserId AND ur2.Active = 1
						LEFT JOIN Roles r2 ON ur2.RoleId = r2.RoleId AND r2.Active = 1
						WHERE u2.Active = 1
							AND (@TenantId IS NULL OR u2.TenantId = @TenantId)
							AND (@Search IS NULL OR u2.FirstName + ' ' + u2.LastName LIKE '%' + @Search + '%' OR u2.Email LIKE '%' + @Search + '%')
							AND (@Role IS NULL OR r2.RoleName = @Role)
							AND (@Status IS NULL OR 
								(@Status = 'active' AND u2.Active = 1 AND u2.AccountLocked = 0) OR
								(@Status = 'locked' AND u2.AccountLocked = 1) OR
								(@Status = 'inactive' AND u2.Active = 0)
							)
						ORDER BY u2.CreatedAt DESC
						OFFSET @Offset ROWS
						FETCH NEXT @Limit ROWS ONLY
					)
					ORDER BY u.UserId, p.PermissionName;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADMIN_UPDATE_USER_ROLE">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADMIN_UPDATE_USER_ROLE]
				@AdminUserId BIGINT,
				@UserId BIGINT,
				@TenantId BIGINT = NULL,
				@RoleName NVARCHAR(50),
				@Permissions NVARCHAR(MAX) = NULL, -- JSON array of permission names
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @RoleId BIGINT;
					DECLARE @TargetUserName NVARCHAR(200);
					DECLARE @OldRoleName NVARCHAR(50);
					
					-- Validate admin user exists and has admin role
					IF NOT EXISTS (
						SELECT 1 FROM Users u
						INNER JOIN UserRoles ur ON u.UserId = ur.UserId
						INNER JOIN Roles r ON ur.RoleId = r.RoleId
						WHERE u.UserId = @AdminUserId 
							AND u.Active = 1 
							AND r.RoleName IN ('Admin', 'SuperAdmin')
							AND ur.Active = 1
					)
					BEGIN
						RAISERROR('Admin user not found or insufficient privileges.', 16, 1);
						RETURN;
					END
					
					-- Validate target user exists
					SELECT 
						@TargetUserName = u.FirstName + ' ' + u.LastName
					FROM Users u
					WHERE u.UserId = @UserId 
						AND u.Active = 1
						AND (@TenantId IS NULL OR u.TenantId = @TenantId);
					
					IF @TargetUserName IS NULL
					BEGIN
						RAISERROR('Target user not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Get current role
					SELECT @OldRoleName = r.RoleName
					FROM UserRoles ur
					INNER JOIN Roles r ON ur.RoleId = r.RoleId
					WHERE ur.UserId = @UserId AND ur.Active = 1;
					
					-- Validate new role exists
					SELECT @RoleId = RoleId
					FROM Roles
					WHERE RoleName = @RoleName AND Active = 1;
					
					IF @RoleId IS NULL
					BEGIN
						RAISERROR('Role not found: %s', 16, 1, @RoleName);
						RETURN;
					END
					
					-- Deactivate current user roles
					UPDATE UserRoles
					SET 
						Active = 0,
						UpdatedAt = @CurrentTime
					WHERE UserId = @UserId AND Active = 1;
					
					-- Assign new role
					INSERT INTO UserRoles (
						UserId,
						RoleId,
						AssignedBy,
						AssignedAt,
						CreatedAt,
						UpdatedAt,
						Active
					) VALUES (
						@UserId,
						@RoleId,
						@AdminUserId,
						@CurrentTime,
						@CurrentTime,
						@CurrentTime,
						1
					);
					
					-- Handle custom permissions if provided
					IF @Permissions IS NOT NULL AND @Permissions != ''
					BEGIN
						-- Remove existing custom permissions for this user
						DELETE FROM UserCustomPermissions 
						WHERE UserId = @UserId;
						
						-- Parse and insert new permissions
						DECLARE @PermissionName NVARCHAR(100);
						DECLARE @PermissionId BIGINT;
						
						-- Use OPENJSON to parse the permissions array
						DECLARE permission_cursor CURSOR FOR
						SELECT JSON_VALUE(value, '$') AS PermissionName
						FROM OPENJSON(@Permissions);
						
						OPEN permission_cursor;
						FETCH NEXT FROM permission_cursor INTO @PermissionName;
						
						WHILE @@FETCH_STATUS = 0
						BEGIN
							-- Get permission ID
							SELECT @PermissionId = PermissionId
							FROM Permissions
							WHERE PermissionName = @PermissionName AND Active = 1;
							
							-- Insert custom permission if valid
							IF @PermissionId IS NOT NULL
							BEGIN
								INSERT INTO UserCustomPermissions (
									UserId,
									PermissionId,
									GrantedBy,
									GrantedAt,
									CreatedAt,
									Active
								) VALUES (
									@UserId,
									@PermissionId,
									@AdminUserId,
									@CurrentTime,
									@CurrentTime,
									1
								);
							END
							
							FETCH NEXT FROM permission_cursor INTO @PermissionName;
						END
						
						CLOSE permission_cursor;
						DEALLOCATE permission_cursor;
					END
					
					-- Log the role change activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt,
						PerformedBy
					) VALUES (
						@UserId,
						'ROLE_UPDATED',
						'User role updated from ' + ISNULL(@OldRoleName, 'None') + ' to ' + @RoleName + ' by admin',
						@IpAddress,
						@UserAgent,
						@CurrentTime,
						@AdminUserId
					);
					
					-- Log admin activity
					INSERT INTO UserActivityLog (
						UserId,
						ActivityType,
						ActivityDescription,
						IpAddress,
						UserAgent,
						CreatedAt
					) VALUES (
						@AdminUserId,
						'ADMIN_ROLE_UPDATE',
						'Updated role for user ' + @TargetUserName + ' from ' + ISNULL(@OldRoleName, 'None') + ' to ' + @RoleName,
						@IpAddress,
						@UserAgent,
						@CurrentTime
					);
					
					-- Return updated user role information
					SELECT 
						@UserId AS UserId,
						@TargetUserName AS UserName,
						@OldRoleName AS PreviousRole,
						@RoleName AS NewRole,
						@AdminUserId AS UpdatedBy,
						@CurrentTime AS UpdatedAt,
						'User role updated successfully' AS Message;
					
					-- Return assigned permissions
					SELECT 
						p.PermissionName,
						p.PermissionDescription,
						CASE 
							WHEN ucp.PermissionId IS NOT NULL THEN 'Custom'
							ELSE 'Role-based'
						END AS PermissionSource
					FROM (
						-- Role-based permissions
						SELECT rp.PermissionId
						FROM UserRoles ur
						INNER JOIN RolePermissions rp ON ur.RoleId = rp.RoleId
						WHERE ur.UserId = @UserId AND ur.Active = 1 AND rp.Active = 1
						
						UNION
						
						-- Custom permissions
						SELECT ucp.PermissionId
						FROM UserCustomPermissions ucp
						WHERE ucp.UserId = @UserId AND ucp.Active = 1
					) combinedPermissions
					INNER JOIN Permissions p ON combinedPermissions.PermissionId = p.PermissionId
					LEFT JOIN UserCustomPermissions ucp ON p.PermissionId = ucp.PermissionId AND ucp.UserId = @UserId AND ucp.Active = 1
					WHERE p.Active = 1
					ORDER BY p.PermissionName;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed role update
					IF @AdminUserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@AdminUserId,
							'ADMIN_ROLE_UPDATE_FAILED',
							'Failed to update user role: ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADMIN_GET_ALL_ORDERS">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADMIN_GET_ALL_ORDERS]
				@AdminUserId BIGINT,
				@TenantId BIGINT = NULL,
				@Page INT = 1,
				@Limit INT = 10,
				@Status NVARCHAR(50) = NULL,
				@Search NVARCHAR(100) = NULL,
				@StartDate DATETIME = NULL,
				@EndDate DATETIME = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					DECLARE @Offset INT;
					DECLARE @TotalCount INT;
					
					-- Calculate offset for pagination
					SET @Offset = (@Page - 1) * @Limit;
					
					-- Validate admin user exists and has admin role
					IF NOT EXISTS (
						SELECT 1 FROM Users u
						INNER JOIN UserRoles ur ON u.UserId = ur.UserId
						INNER JOIN Roles r ON ur.RoleId = r.RoleId
						WHERE u.UserId = @AdminUserId 
							AND u.Active = 1 
							AND r.RoleName IN ('Admin', 'SuperAdmin')
							AND ur.Active = 1
					)
					BEGIN
						RAISERROR('User not found or insufficient privileges.', 16, 1);
						RETURN;
					END
					
					-- Set default date range if not provided
					IF @StartDate IS NULL
						SET @StartDate = DATEADD(MONTH, -6, GETUTCDATE()); -- Last 6 months
					
					IF @EndDate IS NULL
						SET @EndDate = GETUTCDATE();
					
					-- Get total count for pagination
					SELECT @TotalCount = COUNT(*)
					FROM Orders o
					INNER JOIN Users u ON o.UserId = u.UserId
					WHERE o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
						AND (@Status IS NULL OR o.OrderStatus = @Status)
						AND (@Search IS NULL OR 
							o.OrderNumber LIKE '%' + @Search + '%' OR 
							u.FirstName + ' ' + u.LastName LIKE '%' + @Search + '%' OR
							u.Email LIKE '%' + @Search + '%'
						)
						AND o.CreatedAt >= @StartDate
						AND o.CreatedAt <= @EndDate;
					
					-- Get orders with pagination
					SELECT 
						o.OrderId,
						o.OrderNumber,
						u.FirstName + ' ' + u.LastName AS CustomerName,
						u.Email AS CustomerEmail,
						u.Phone AS CustomerPhone,
						o.OrderStatus AS Status,
						o.PaymentStatus,
						o.TotalAmount AS Total,
						o.Subtotal,
						o.ShippingAmount,
						o.TaxAmount,
						o.DiscountAmount,
						-- Calculate item statistics
						ISNULL(orderItems.ItemCount, 0) AS ItemCount,
						ISNULL(orderItems.TotalQuantity, 0) AS TotalQuantity,
						o.CreatedAt,
						o.UpdatedAt,
						o.ShippedAt,
						o.DeliveredAt,
						o.ShippingAddress,
						o.BillingAddress,
						o.PaymentMethod,
						o.ShippingMethod,
						o.Notes,
						-- Estimated delivery calculation
						CASE 
							WHEN o.OrderStatus = 'Delivered' THEN o.DeliveredAt
							WHEN o.OrderStatus = 'Shipped' THEN DATEADD(DAY, 3, ISNULL(o.ShippedAt, o.UpdatedAt))
							WHEN o.OrderStatus IN ('Processing', 'Confirmed') THEN DATEADD(DAY, 5, o.CreatedAt)
							ELSE DATEADD(DAY, 7, o.CreatedAt)
						END AS EstimatedDelivery,
						-- Customer information
						u.UserId AS CustomerId,
						u.TenantId AS CustomerTenantId,
						-- Pagination info
						@TotalCount AS TotalCount,
						@Page AS CurrentPage,
						@Limit AS PageSize,
						CEILING(CAST(@TotalCount AS FLOAT) / @Limit) AS TotalPages,
						CASE WHEN @Page < CEILING(CAST(@TotalCount AS FLOAT) / @Limit) THEN 1 ELSE 0 END AS HasNext,
						CASE WHEN @Page > 1 THEN 1 ELSE 0 END AS HasPrevious
					FROM Orders o
					INNER JOIN Users u ON o.UserId = u.UserId
					LEFT JOIN (
						SELECT 
							oi.OrderId,
							COUNT(oi.OrderItemId) AS ItemCount,
							SUM(oi.Quantity) AS TotalQuantity
						FROM OrderItems oi
						WHERE oi.Active = 1
						GROUP BY oi.OrderId
					) orderItems ON o.OrderId = orderItems.OrderId
					WHERE o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
						AND (@Status IS NULL OR o.OrderStatus = @Status)
						AND (@Search IS NULL OR 
							o.OrderNumber LIKE '%' + @Search + '%' OR 
							u.FirstName + ' ' + u.LastName LIKE '%' + @Search + '%' OR
							u.Email LIKE '%' + @Search + '%'
						)
						AND o.CreatedAt >= @StartDate
						AND o.CreatedAt <= @EndDate
					ORDER BY o.CreatedAt DESC
					OFFSET @Offset ROWS
					FETCH NEXT @Limit ROWS ONLY;
					
					-- Get order items for each order in the result set
					SELECT 
						oi.OrderId,
						oi.OrderItemId,
						oi.ProductId,
						oi.ProductName,
						oi.ProductImage,
						oi.Price,
						oi.Quantity,
						oi.Total,
						p.ProductCode,
						p.Category,
						p.Rating,
						p.Offer
					FROM OrderItems oi
					LEFT JOIN Products p ON oi.ProductId = p.ProductId
					WHERE oi.OrderId IN (
						SELECT o.OrderId
						FROM Orders o
						INNER JOIN Users u ON o.UserId = u.UserId
						WHERE o.Active = 1
							AND (@TenantId IS NULL OR o.TenantId = @TenantId)
							AND (@Status IS NULL OR o.OrderStatus = @Status)
							AND (@Search IS NULL OR 
								o.OrderNumber LIKE '%' + @Search + '%' OR 
								u.FirstName + ' ' + u.LastName LIKE '%' + @Search + '%' OR
								u.Email LIKE '%' + @Search + '%'
							)
							AND o.CreatedAt >= @StartDate
							AND o.CreatedAt <= @EndDate
						ORDER BY o.CreatedAt DESC
						OFFSET @Offset ROWS
						FETCH NEXT @Limit ROWS ONLY
					)
					AND oi.Active = 1
					ORDER BY oi.OrderId, oi.OrderItemId;
					
					-- Get order statistics summary
					SELECT 
						COUNT(*) AS TotalOrders,
						SUM(o.TotalAmount) AS TotalRevenue,
						AVG(o.TotalAmount) AS AverageOrderValue,
						COUNT(DISTINCT o.UserId) AS UniqueCustomers,
						SUM(CASE WHEN o.OrderStatus = 'Pending' THEN 1 ELSE 0 END) AS PendingOrders,
						SUM(CASE WHEN o.OrderStatus = 'Processing' THEN 1 ELSE 0 END) AS ProcessingOrders,
						SUM(CASE WHEN o.OrderStatus = 'Shipped' THEN 1 ELSE 0 END) AS ShippedOrders,
						SUM(CASE WHEN o.OrderStatus = 'Delivered' THEN 1 ELSE 0 END) AS DeliveredOrders,
						SUM(CASE WHEN o.OrderStatus = 'Cancelled' THEN 1 ELSE 0 END) AS CancelledOrders
					FROM Orders o
					WHERE o.Active = 1
						AND (@TenantId IS NULL OR o.TenantId = @TenantId)
						AND o.CreatedAt >= @StartDate
						AND o.CreatedAt <= @EndDate;
					
				END TRY
				BEGIN CATCH
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_ADD_PRODUCT_IMAGES">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_ADD_PRODUCT_IMAGES]
				@ProductId BIGINT,
				@UserId BIGINT = NULL,
				@TenantId BIGINT = NULL,
				@Images NVARCHAR(MAX), -- JSON array of image data
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @ImageCount INT = 0;
					DECLARE @BaseUrl NVARCHAR(500) = 'https://cdn.example.com/images/';
					
					-- Validate product exists and is active
					IF NOT EXISTS (SELECT 1 FROM Products WHERE ProductId = @ProductId AND Active = 1)
					BEGIN
						RAISERROR('Product not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate user if provided
					IF @UserId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Create temporary table to store image data
					CREATE TABLE #TempImages (
						ImageName NVARCHAR(255),
						ContentType NVARCHAR(100),
						FileSize BIGINT,
						ImageData VARBINARY(MAX),
						ThumbnailData VARBINARY(MAX),
						IsMain BIT,
						OrderBy INT,
						ImageUrl NVARCHAR(500)
					);
					
					-- Parse JSON and insert into temporary table
					INSERT INTO #TempImages (ImageName, ContentType, FileSize, ImageData, ThumbnailData, IsMain, OrderBy, ImageUrl)
					SELECT 
						JSON_VALUE(value, '$.imageName') AS ImageName,
						JSON_VALUE(value, '$.contentType') AS ContentType,
						CAST(JSON_VALUE(value, '$.fileSize') AS BIGINT) AS FileSize,
						CAST(JSON_VALUE(value, '$.imageData') AS VARBINARY(MAX)) AS ImageData,
						CAST(JSON_VALUE(value, '$.thumbnailData') AS VARBINARY(MAX)) AS ThumbnailData,
						CAST(JSON_VALUE(value, '$.isMain') AS BIT) AS IsMain,
						CAST(JSON_VALUE(value, '$.orderBy') AS INT) AS OrderBy,
						@BaseUrl + 'product_' + CAST(@ProductId AS VARCHAR(20)) + '_' + JSON_VALUE(value, '$.imageName') AS ImageUrl
					FROM OPENJSON(@Images);
					
					-- Count images to be added
					SELECT @ImageCount = COUNT(*) FROM #TempImages;
					
					-- Validate at least one image
					IF @ImageCount = 0
					BEGIN
						RAISERROR('At least one image is required.', 16, 1);
						RETURN;
					END
					
					-- If main image is specified, unset other main images for this product
					IF EXISTS (SELECT 1 FROM #TempImages WHERE IsMain = 1)
					BEGIN
						UPDATE ProductImages
						SET 
							Main = 0,
							Modified = @CurrentTime
						WHERE ProductId = @ProductId AND Active = 1;
					END
					
					-- Insert new images
					INSERT INTO ProductImages (
						ProductId,
						ImageName,
						ContentType,
						FileSize,
						ImageData,
						ThumbnailData,
						Poster,
						Main,
						Active,
						OrderBy,
						CreatedAt,
						Modified,
						CreatedBy
					)
					SELECT 
						@ProductId,
						ti.ImageName,
						ti.ContentType,
						ti.FileSize,
						ti.ImageData,
						ti.ThumbnailData,
						ti.ImageUrl,
						ti.IsMain,
						1, -- Active
						ti.OrderBy,
						@CurrentTime,
						@CurrentTime,
						@UserId
					FROM #TempImages ti;
					
					-- Update product modified date
					UPDATE Products
					SET Modified = @CurrentTime
					WHERE ProductId = @ProductId;
					
					-- Log the image addition activity
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PRODUCT_IMAGES_ADDED',
							'Added ' + CAST(@ImageCount AS VARCHAR(10)) + ' images to product ID: ' + CAST(@ProductId AS VARCHAR(20)),
							@IpAddress,
							@UserAgent,
							@CurrentTime
						);
					END
					
					-- Return inserted images
					SELECT 
						pi.ImageId,
						pi.ProductId,
						pi.Poster,
						pi.Main,
						pi.Active,
						pi.OrderBy,
						pi.CreatedAt AS Created,
						pi.Modified,
						pi.ImageName,
						pi.ContentType,
						pi.FileSize
					FROM ProductImages pi
					WHERE pi.ProductId = @ProductId 
						AND pi.CreatedAt = @CurrentTime
						AND pi.Active = 1
					ORDER BY pi.OrderBy, pi.ImageId;
					
					-- Clean up temporary table
					DROP TABLE #TempImages;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
					
					-- Clean up temporary table if exists
					IF OBJECT_ID('tempdb..#TempImages') IS NOT NULL
						DROP TABLE #TempImages;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed image addition
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PRODUCT_IMAGES_ADD_FAILED',
							'Failed to add images to product ID: ' + CAST(@ProductId AS VARCHAR(20)) + ' - ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_UPDATE_PRODUCT_IMAGE">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_UPDATE_PRODUCT_IMAGE]
				@ProductId BIGINT,
				@ImageId BIGINT,
				@UserId BIGINT = NULL,
				@TenantId BIGINT = NULL,
				@IsMain BIT = NULL,
				@Active BIT = NULL,
				@OrderBy INT = NULL,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @OldMain BIT;
					DECLARE @OldActive BIT;
					DECLARE @OldOrderBy INT;
					DECLARE @ImageName NVARCHAR(255);
					
					-- Validate product exists and is active
					IF NOT EXISTS (SELECT 1 FROM Products WHERE ProductId = @ProductId AND Active = 1)
					BEGIN
						RAISERROR('Product not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate image exists and belongs to product
					SELECT 
						@OldMain = Main,
						@OldActive = Active,
						@OldOrderBy = OrderBy,
						@ImageName = ImageName
					FROM ProductImages 
					WHERE ImageId = @ImageId AND ProductId = @ProductId;
					
					IF @ImageName IS NULL
					BEGIN
						RAISERROR('Image not found or does not belong to this product.', 16, 1);
						RETURN;
					END
					
					-- Validate user if provided
					IF @UserId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- If setting as main image, unset other main images for this product
					IF @IsMain = 1 AND @OldMain = 0
					BEGIN
						UPDATE ProductImages
						SET 
							Main = 0,
							Modified = @CurrentTime
						WHERE ProductId = @ProductId AND ImageId != @ImageId AND Active = 1;
					END
					
					-- Update the image
					UPDATE ProductImages
					SET 
						Main = ISNULL(@IsMain, Main),
						Active = ISNULL(@Active, Active),
						OrderBy = ISNULL(@OrderBy, OrderBy),
						Modified = @CurrentTime,
						ModifiedBy = @UserId
					WHERE ImageId = @ImageId AND ProductId = @ProductId;
					
					-- Update product modified date
					UPDATE Products
					SET Modified = @CurrentTime
					WHERE ProductId = @ProductId;
					
					-- Log the image update activity
					IF @UserId IS NOT NULL
					BEGIN
						DECLARE @Changes NVARCHAR(1000) = '';
						
						IF @IsMain IS NOT NULL AND @IsMain != @OldMain
							SET @Changes = @Changes + 'Main: ' + CAST(@OldMain AS VARCHAR(5)) + ' → ' + CAST(@IsMain AS VARCHAR(5)) + '; ';
						
						IF @Active IS NOT NULL AND @Active != @OldActive
							SET @Changes = @Changes + 'Active: ' + CAST(@OldActive AS VARCHAR(5)) + ' → ' + CAST(@Active AS VARCHAR(5)) + '; ';
						
						IF @OrderBy IS NOT NULL AND @OrderBy != @OldOrderBy
							SET @Changes = @Changes + 'OrderBy: ' + CAST(@OldOrderBy AS VARCHAR(10)) + ' → ' + CAST(@OrderBy AS VARCHAR(10)) + '; ';
						
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PRODUCT_IMAGE_UPDATED',
							'Updated image ' + @ImageName + ' for product ID: ' + CAST(@ProductId AS VARCHAR(20)) + 
							CASE WHEN LEN(@Changes) > 0 THEN ' - Changes: ' + @Changes ELSE '' END,
							@IpAddress,
							@UserAgent,
							@CurrentTime
						);
					END
					
					-- Return updated image
					SELECT 
						pi.ImageId,
						pi.ProductId,
						pi.Poster,
						pi.Main,
						pi.Active,
						pi.OrderBy,
						pi.CreatedAt AS Created,
						pi.Modified,
						pi.ImageName,
						pi.ContentType,
						pi.FileSize,
						'Image updated successfully' AS Message
					FROM ProductImages pi
					WHERE pi.ImageId = @ImageId AND pi.ProductId = @ProductId;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed image update
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PRODUCT_IMAGE_UPDATE_FAILED',
							'Failed to update image ID: ' + CAST(@ImageId AS VARCHAR(20)) + ' for product ID: ' + CAST(@ProductId AS VARCHAR(20)) + ' - ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
	<query Id="SP_DELETE_PRODUCT_IMAGE">
		<![CDATA[
			CREATE PROCEDURE [dbo].[SP_DELETE_PRODUCT_IMAGE]
				@ProductId BIGINT,
				@ImageId BIGINT,
				@UserId BIGINT = NULL,
				@TenantId BIGINT = NULL,
				@HardDelete BIT = 0,
				@IpAddress NVARCHAR(45) = NULL,
				@UserAgent NVARCHAR(500) = NULL
			AS
			BEGIN
				SET NOCOUNT ON;
				
				BEGIN TRY
					BEGIN TRANSACTION;
					
					DECLARE @CurrentTime DATETIME = GETUTCDATE();
					DECLARE @ImageName NVARCHAR(255);
					DECLARE @IsMain BIT;
					DECLARE @IsActive BIT;
					
					-- Validate product exists and is active
					IF NOT EXISTS (SELECT 1 FROM Products WHERE ProductId = @ProductId AND Active = 1)
					BEGIN
						RAISERROR('Product not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Validate image exists and belongs to product
					SELECT 
						@ImageName = ImageName,
						@IsMain = Main,
						@IsActive = Active
					FROM ProductImages 
					WHERE ImageId = @ImageId AND ProductId = @ProductId;
					
					IF @ImageName IS NULL
					BEGIN
						RAISERROR('Image not found or does not belong to this product.', 16, 1);
						RETURN;
					END
					
					-- Check if image is already deleted (soft delete)
					IF @IsActive = 0 AND @HardDelete = 0
					BEGIN
						RAISERROR('Image is already deleted.', 16, 1);
						RETURN;
					END
					
					-- Validate user if provided
					IF @UserId IS NOT NULL AND NOT EXISTS (SELECT 1 FROM Users WHERE UserId = @UserId AND Active = 1)
					BEGIN
						RAISERROR('User not found or inactive.', 16, 1);
						RETURN;
					END
					
					-- Check if this is the last active image for the product
					DECLARE @ActiveImageCount INT;
					SELECT @ActiveImageCount = COUNT(*)
					FROM ProductImages 
					WHERE ProductId = @ProductId AND Active = 1 AND ImageId != @ImageId;
					
					-- Prevent deletion of the last image if it's the main image
					IF @ActiveImageCount = 0 AND @IsMain = 1
					BEGIN
						RAISERROR('Cannot delete the last active main image. Please add another image first.', 16, 1);
						RETURN;
					END
					
					-- Perform deletion
					IF @HardDelete = 1
					BEGIN
						-- Hard delete: Remove from database completely
						DELETE FROM ProductImages
						WHERE ImageId = @ImageId AND ProductId = @ProductId;
					END
					ELSE
					BEGIN
						-- Soft delete: Mark as inactive
						UPDATE ProductImages
						SET 
							Active = 0,
							Main = 0, -- Remove main status if it was main
							Modified = @CurrentTime,
							ModifiedBy = @UserId,
							DeletedAt = @CurrentTime,
							DeletedBy = @UserId
						WHERE ImageId = @ImageId AND ProductId = @ProductId;
					END
					
					-- If deleted image was main, set another active image as main
					IF @IsMain = 1 AND @ActiveImageCount > 0
					BEGIN
						UPDATE ProductImages
						SET 
							Main = 1,
							Modified = @CurrentTime
						WHERE ProductId = @ProductId 
							AND Active = 1 
							AND ImageId = (
								SELECT TOP 1 ImageId 
								FROM ProductImages 
								WHERE ProductId = @ProductId AND Active = 1 
								ORDER BY OrderBy, ImageId
							);
					END
					
					-- Update product modified date
					UPDATE Products
					SET Modified = @CurrentTime
					WHERE ProductId = @ProductId;
					
					-- Log the image deletion activity
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							CASE WHEN @HardDelete = 1 THEN 'PRODUCT_IMAGE_HARD_DELETED' ELSE 'PRODUCT_IMAGE_SOFT_DELETED' END,
							CASE WHEN @HardDelete = 1 THEN 'Permanently deleted' ELSE 'Soft deleted' END + 
							' image ' + @ImageName + ' from product ID: ' + CAST(@ProductId AS VARCHAR(20)),
							@IpAddress,
							@UserAgent,
							@CurrentTime
						);
					END
					
					-- Return deletion confirmation
					SELECT 
						@ImageId AS ImageId,
						@ProductId AS ProductId,
						@ImageName AS ImageName,
						@IsMain AS WasMain,
						@HardDelete AS HardDeleted,
						@CurrentTime AS DeletedAt,
						@UserId AS DeletedBy,
						CASE WHEN @HardDelete = 1 THEN 'Image permanently deleted' ELSE 'Image soft deleted' END AS Message,
						@ActiveImageCount AS RemainingActiveImages;
					
					-- Return current active images for the product
					SELECT 
						pi.ImageId,
						pi.ProductId,
						pi.Poster,
						pi.Main,
						pi.Active,
						pi.OrderBy,
						pi.CreatedAt AS Created,
						pi.Modified
					FROM ProductImages pi
					WHERE pi.ProductId = @ProductId AND pi.Active = 1
					ORDER BY pi.OrderBy, pi.ImageId;
					
					COMMIT TRANSACTION;
					
				END TRY
				BEGIN CATCH
					IF @@TRANCOUNT > 0
						ROLLBACK TRANSACTION;
						
					DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
					DECLARE @ErrorSeverity INT = ERROR_SEVERITY();
					DECLARE @ErrorState INT = ERROR_STATE();
					
					-- Log the failed image deletion
					IF @UserId IS NOT NULL
					BEGIN
						INSERT INTO UserActivityLog (
							UserId,
							ActivityType,
							ActivityDescription,
							IpAddress,
							UserAgent,
							CreatedAt
						) VALUES (
							@UserId,
							'PRODUCT_IMAGE_DELETE_FAILED',
							'Failed to delete image ID: ' + CAST(@ImageId AS VARCHAR(20)) + ' from product ID: ' + CAST(@ProductId AS VARCHAR(20)) + ' - ' + @ErrorMessage,
							@IpAddress,
							@UserAgent,
							GETUTCDATE()
						);
					END
					
					RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState);
				END CATCH
			END
		]]>
	</query>
</queries>